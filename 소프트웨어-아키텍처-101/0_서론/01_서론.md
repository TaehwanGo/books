# 1. 서론

### 소프트웨어 아키텍트에 대한 정의가 분명하지 않다

- 소프트웨어 아키텍트(software architect)는 다른 직업에 비해 커리어패스(career path, 직업 경로)가 분명하지 않은 것 같다. 왜 그럴까요?

> 첫째, 소프트웨어 아키텍트라는 직업 자체에 대한 명확한 정의가 아직도 없습니다

- 소프트웨어 아키텍트는 유일하게 규정지을 수 있는 사람들이 아닙니다

- 소프트웨어 아키텍트 마인드맵

![소프트웨어 아키텍트 마인드맵](./images/1-1.jpeg)

- 그림 1-1. 소프트웨어 아키텍트의 업무는 기술 역량, 소프트 스킬, 운영 감각 등 많은 분야를 아우른다

> 둘째, 마인드맵만 봐도 알 수 있듯이 소프트웨어 아키텍트의 역할은 실로 방대한 분야를 포괄하며 업무 범위도 계속 넓어지고 있습니다

- 10년 전만 해도 소프트웨어 아키텍트는 주로 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분을 다루었지만,
  - 이제는 (마이크로서비스처럼) 훨씬 폭넓은 능력을 활용하는 새로운 아키텍처 스타일의 등장으로 인해 그 역할과 범위가 한층 더 확대되었습니다

> 셋째, 소프트웨어 개발 생태계는 워낙 빠르게 발전하는 분야이고 소프트웨어 아키텍처는 끊임없이 변합니다

- 소프트웨어 아키텍처가 '일단 구축한 이후에 변경하려면 비용이 드는 근본적인 구조를 선택하는 일'이라고 나와 있는데 이 또한 철지난 문장입니다
  - 마이크로 서비스 같은 요즘 아키텍처 스타일은 단계적으로 구축한다는 개념에 기반을 두기 때문에 구조를 변경하는 작업도 그리 비싸지 않습니다
- 물론, 이런 능력은 커플링 등의 다른 관심사와 언제나 트레이드오프가 존재하며, 대부분의 소프트웨어 아키텍처 도서는 이것을 정적인 문제로 취급합니다
  - 일단 해결되면 안심하고 무시해도 되는 문제라고 보지만 이는 잘못된 생각입니다
  - 앞으로 이 책에서 소프트웨어 아키텍처는 그 정의를 포함한 본질 자체가 동적입니다

> 넷째, 소프트웨어 아키텍처에 관한 자료는 대부분 역사적인 연관성을 강조합니다

- 수년 전까지 들어맞았던 솔루션도 상황이 달라지면서 지금은 돌아가지 않는 것들도 수두룩합니다
- 소프트웨어 아키텍처의 역사는 과거 아키텍트들이 시도했으나 해로운 부수 효과만 식별하게 된 것들로 난잡하게 얽혀 있습니다
- 이 책은 그 과정에서 얻은 많은 교훈들을 이야기합니다

### 아키텍처 기초에 관한 책이 무슨 소용일까요?

- 소프트웨어 아키텍처의 범위는 끊임없이 변화하는 개발 세상의 유일한 요소가 아닙니다
- 새로운 기술, 기법, 기능, ... 지난 수십 년간 달라진 것들을 나열하는 것보다 외려 달라지지 않은 것을 찾아보는 게 더 쉬울 정도입니다
- 소프트웨어 아키텍트는 이렇게 끊임없이 변하는 생태계안에서 뭔가 결정을 내리는 사람들입니다
  - 그렇게 결정한 기반을 비롯한 모든 것이 변하므로 과거 아키텍처에 관한 글에서 강조한 핵심 원칙들도 다시 검토해봐야 합니다
- 예를 들면, 예전엔 데브옵스라는 개념이 존재하지 않았으니 데브옵스의 영향은 하나도 고려하지 않았습니다

- 아키텍처란 문맥으로 이해할 수 있습니다
  - 예전엔 효율적인 리소스를 공유하여 사용하는 것이 목표
    - 인프라 가격이 비쌌기 때문
- 오픈소스가 개발되고 데브옵스 혁명을 통해 엔지니어링 프랙티스가 향상된 덕분에 지금은 아키텍처를 얼마든지 구축할 수 있게 되었습니다
  - 윈도우, 데이터베이스 라이선스를 여러개 구입할 필요가 없다

## 1.1 소프트웨어 아키텍처란?

- '청사진', '이정표'라는 말이 실제로 의미하는 바는 무엇인지 이해해야한다
- 아키텍트가 시스템을 '분석'한다면 과연 무엇을 '분석'한다는 말일까요?

![1-2](./images/1-2.jpeg)

- 그림 1-2. 아키텍처는 아키텍처 특성, 아키텍처 결정, 설계 원칙이 결합된 구조다
- 그림 1-2는 소프트웨어 아키텍처를 바라보는 방법 중 하나입니다
  - 아키텍처 특성
  - 아키텍처 결정
  - 설계 원칙
  - 시스템 구조

![1-3](./images/1-3.jpeg)

- 그림 1-3. 구조는 시스템에 어떤 종류의 아키텍처 스타일을 적용했는지를 나타낸다

#### `시스템 구조`란 시스템이 구현된(마이크로서비스, 레이어드, 마이크로커널 같은) 아키텍처 스타일(들)의 종류를 말합니다(그림 1-3)

- 하지만 구조만으로 아키텍처를 전체적으로 설명하기에 부족합니다

  - 가령 아키텍처를 설명해달라는 요청에 "마이크로서비스 아키텍처입니다"라고 대답했다면?
    - 그는 시스템의 구조만 언급했을 뿐, 시스템의 아키텍처를 이야기한 것이 아닙니다
  - 시스템의 아키텍처를 완전히 이해하려면 아키텍처 특성, 아키텍처 결정, 설계 원칙도 알아야 합니다

- 아키텍처 특성은 소프트웨어 아키텍처를 다른 관점에서 바라본 것으로, 일반적으로 시스템의 기능과 직교하는 시스템의 성공 기준을 결정합니다

![1-4](./images/1-4.jpeg)

#### `아키텍처 특성`은 시스템이 지원해야 하는 '~성'들이다

- 아키텍처 특성은 소프트웨어 아키텍처를 다른 관점에서 바라본 것으로, 일반적으로 시스템의 기능과 직교하는 시스템의 성공 기준을 결정합니다(그림 1-4).
- 여기에 나열된 모든 아키텍처 특성이 시스템 기능에 관한 지식을 필요로 하는 것은 아니지만, 시스템이 올바르게 동작하기 위해서는 반드시 필요한 것들입니다

![1-5](./images/1-5.jpeg)

- 그림 1-5. 아키텍처 결정은 시스템을 구축하는 규칙이다

#### 소프트웨어 아키텍처를 규정하는 또 다른 측면은 `아키텍처 결정`입니다

- 소프트웨어 결정은 시스템 구축에 필요한 규칙들을 정한 것입니다
  - e.g. '레이어드(게층화) 아키텍처에서는 프레젠테이션 레이어가 데이터베이스를 직접 호출하지 못하게 비즈니스와 서비스 레이어에서만 데이터베이스에 액세스할 수 있다'고 결정하는 식입니다
- 아키텍처 결정은 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지말아야 할 것을 알려줍니다

- 어떤 상황 때문에, 또는 다른 제약조건 탓에 이전에 만든 결정을 따를 수 없다면 변형을 통해 깨뜨릴 수 있습니다
  - 아키텍처 심사 위원회(ARB, Architecture Review Board)에서 사용하는 변형 모델을 갖고 있는 회사들이 많은데, 이 모델은 어떤 표준이나 아키텍처 결정의 변형을 추구하는 프로세스를 규정합니다
- 아키텍처 결정에 대한 예외는 ARB가 검토하여 타당한 근거와 트레이드오프를 고려한 뒤 승인/거부합니다

#### 아키텍처를 정의하는 마지막 요소는 `설계 원칙`입니다

![1-6](./images/1-6.jpeg)

- 그림 1-6. 설계 원칙은 시스템 구축에 필요한 가이드라인이다

- 아키텍처 결정이 반드시 지켜야할 규칙이라면 설계원칙은 가이드라인입니다
  - 예를 들어, 그림 1-6에서 마이크로서비스 아키텍처의 성능 향상을 위해 서비스 간 통신은 비동기 메시징을 활용해야 한다고 기술하는 것이 설계 원칙입니다
- 서비스 간 통신에 관한 모든 조건과 구현 방안을 아키텍처 결정(규칙)으로 다룰 수는 없기에 특정 환경에서 개발자가 더 적합한 (REST나 gRPC 같은) 통신 프로토콜을 선택할 수 있도록 우선 권장하는 방법에 관한 가이드를 설계 원칙으로 제공하는 것입니다
