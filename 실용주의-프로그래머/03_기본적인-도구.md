# 3. 기본적인 도구

- 이 장에서는 자신의 기본 공구상자에 어떻게 투자할지에 대해 이야기 할 것이다

- 일반 텍스트의 힘
  - 원재료들, 모양을 만들어 나갈 재료
- 조개 놀이
  - 작업대(컴퓨터)
- 파워 에디팅
  - 어떤 도구보다도 더 자주 사용하는 도구, 편집기
- 소스코드 관리
  - 이전 작업을 조금이라도 잃어버리지 않기 위해
- 디버깅
- 텍스트 처리
  - 이런 마술들을 한군데 모아 붙일 수 있는 풀
    - 오크(awk), 펄(perl), 파이썬(python)
- 코드 생성기
  - 목수 : 복잡한 걸 만드는 데 가이드를 얻기 위해 지그(Jig, 절삭 공구를 정해진 위치로 이끄는 장치)를 만드는 것
  - 프로그래머 : 코드를 작성하는 코드를 작성하는 것

## 14. 일반 텍스트의 힘

- 실용주의 프로그래머로서 우리의 기본 재료 : 지식
- 요구사항을 지식으로 수집하고 그 지식을 설계, 구현, 테스트 그리고 문서에 표현한다
- 지식을 저장하는 최고의 포맷이 일반 텍스트라고 믿는다

### 일반 텍스트란?

- 일반 텍스트란 사람이 직접 읽고 이해할 수 있는 형태의 인쇄가능한 문자로 이루어진 텍스트
  - 텍스트 이지만 일반 텍스트가 아닌 예: Field19=467abe
    - 이해할 수 없다
- 일반 텍스트라고 해서 비구조적이어야 하는 것만은 아니다
  - XML, SGML, HTML은 잘 정의된 구조를 가진 일반 텍스트의 훌륭한 예다

> Tip 20. 지식을 일반 텍스트로 저장하라

### 단점

- 압축된 이진 포맷을 사용하는 것보다 더 많은 공간을 차지할 수 있고
- 일반 텍스트 파일을 해석하고 처리하는 데에 더 많은 계산이 필요할 수 있다

### 텍스트의 힘

- 일반 텍스트가 주는 이득
  - 구식이 되는 것에 대한 보험
  - 호환성
  - 더 쉬운 테스트

#### 구식이 되는 것에 대한 보험

- 사람이 읽을 수 있는 형태의 데이터는 더 오래 살아남을 것이다
- e.g.
  - bad : `<Field10>640309-1132939</Field10>`
  - good : `<주민번호>640309-1132939</주민번호>`

#### 호환성

- 컴퓨팅 세계의 모든 도구들은 일반텍스트를 다룰 수 있다
- 복잡한 설정을 갖는 애플리케이션이 있다고 가정해보자
  - 설정 파일들이 일반 텍스트로 되어 있다면, 그것을 소스코드 관리 시스템에 둘 수 있을 것이고
    - 그 덕분에 모든 변화의 역사를 자동으로 유지할 수 있을 것이다

#### 더 쉬운 테스트

- 시스템 테스트를 구동하게 할 합성 데이터를 만들기 위해 일반 텍스트를 사용한다면,
  특별한 도구를 만들어야 할 필요 없이 간단히 테스트 데이터를 추가, 업데이트, 수정할 수 있다
- 비슷하게 회귀 테스트의 일반 텍스트 출력을 손쉽게 분석하거나 파이썬 같은 스크립팅 도구를 사용ㅍ해서 좀 더 철저한 조사를 할 수도 있다
  - 회귀 테스트 : 새로운 기능이 앱에 추가 되었을 때, 이전의 테스트 결과와 새로 테스트한 결과가 같은 지 비교해서 기존 기능이 제대로 작동하는지 검사하는 테스트

### 최소 공통 분모

- 이질적인 환경에서는 일반 텍스트의 장점이 모든 단점을 보상하고도 남는다
- 모든 참가자가 공통의 표준을 사용해서 소통하도록 할 필요가 있다면, 일반 텍스트가 바로 그 표준이다
- e.g. XML

### 관련 항목

- 소스코드 관리
- 코드 생성기
- 메타 프로그래밍
- 칠판
- 유비쿼터스 자동화
- 결국은 모두 글쓰기

## 15. 조개 놀이

- 모든 목공은 튼튼하며 믿을만한 작업대를 필요로 한다
- 작업물이 모양을 갖춰가면서 장인은 작업대로 계속 왔다갔다하게 되고, 그 작업대는 목공소의 중심이 된다
- 텍스트 파일들을 다루는 프로그래머에겐 명령어 셸이 작업대가 된다
  - 셸 프롬프트에서 모든 종류의 도구를 불러 쓸 수 있다
    - 파이프(`|`)를 이용해 원 개발자가 결코 꿈꾸지 못한 방식으로 도구를 결합시키면서 파일을 검색할 수 있고,
      - `find . -name '*java' -mtime +7 -print | xargs grep 'java.awt'`
    - 시스템의 상태를 알아볼 수 있으며,
    - 출력을 필터링할 수 있다
    - 또한 셸을 프로그래밍해서 자주 수행하는 활동에 쓸 복잡한 매크로 명령을 만들 수도 있다
- GUI 인터페이스와 IDE에서 자라난 프로그래머들에게 이건 좀 극단적으로 보일지도 모른다
- 마우스로 클릭함으로써 결국 모든 걸 똑같이 잘 할 수 있는 것 아닌가? '아니오'
  - 몇 가지 간단한 조작에는 GUI가 더 빠르고 편리할 수 있다
  - 하지만 모든 작업을 GUI로만 한다면, 여러분이 가진 환경의 전체 능력을 이용하지 못하게 된다
- 일반적인 작업을 자동화할 수 없고, 쓸 수 있는 도구의 풀파워를 사용할 수 없다
  - 게다가 도구를 결합해서 자신에게 꼭 맞는 매크로 도구를 만들 수가 없다
- GUI의 장점은 WYSIWYG, 여러분이 보는 것이 여러분이 얻는 것
  - 하지만 단점은 WYSIAYG, 여러분이 보는 것이 얻는 전부라는 것
- GUI환경의 기능은 일반적으로 설계자의 의도에 따른 제약을 받는다
  - 설계자가 제공하는 모델 이상을 필요로 하더라도 그 이상을 얻을 수 없다
- 여러분은 종종 그 모델 이상을 필요로 한다
  - 실용주의 프로그래머들은 단지 코드를 자르거나, 객체 모델을 개발하거나, 문서를 작성하거나, 빌드 과정을 자동화하거나 하지만은 않는다
  - 이 모든일을 다 한다
- 예. IDE에 코드 전처리기를 결합
  - 이 기능을 위해 IDE의 설계자가 명시적으로 사전에 훅(hook)을 제공하지 않은 이상 불가능하다
- 실용주의 프로그래머로서 여러분은 늘 임시변통의 작업을 수행하길 원한다
  - 해당 GUI가 지원하지 않을 수도 있는 그런 작업 말이다
  - 명령줄은 쿼리나 기타 다른 작업을 수행하기 위해 몇 개의 명령어를 재빨리 결합하려 할 때 사용하기 좋다
- 셸 명령은 어렵거나 불친절해 보일 수 있지만 이것들은 강력하고 간결하다
  - 그리고 셸 명령어들을 결합해서 스크립트 파일을 만들 수 있기 때문에, 여러분이 자주 사용하는 작업들을 자동화할 수 있다

> Tip 21. 명령어 셸의 힘을 사용하라

### 셸 유틸리티와 윈도우 시스템

- 윈도우 시스템이 제공하는 명령어 셸은 유닉스에 비해 열악하다
- 윈도우에 유닉스 유틸리티 모음을 사용할 수 있는 방법도 있다

### 관련 항목

- 유비쿼터스 자동화

## 16. 파워 에디팅

- 여러분의 에디팅 환경에서 최대한을 이끌어 낼 수 있게 도와주는 몇 가지 일반적인 기능을 알아보도록 하자

### 하나의 에디터

- 코드, 문서, 이메일 등을 사용할 때 각기 다른 에디터를 사용하면 어느 환경에도 능숙해지기 어렵다
  - 단축키 등

> Tip 22. 하나의 에디터를 잘 사용하라

- 에디터를 하나 골라서 완전히 마스터하고, 모든 편집 작업에 그 에디터를 사용하라

### 에디터의 기능

- 에디터라면 갖추어야 할 기능 몇 가지
  - 설정변경 가능
    - 에디터의 모든 요소 - 폰트, 색, 윈도우 크기, 키입력 바인딩(어느 키가 어떤 명령을 수행하는지) 등
    - 확장 가능
      - 어떤 컴파일러 환경과도 결합할 수 있어야 한다
      - 새로운 언어나 텍스트 포맷의 뉘앙스를 에디터에게 가르칠(추가할) 수 있어야 한다
    - 프로그램 가능
      - 복잡하고 다단계의 작업을 수행할 수 있도록 에디터를 프로그램할 수 있어야 한다
      - 매크로나 내장 스크립팅 프로그래밍 언어를 통해 가능하다
- 추가로, 에디터들은 특정 프로그래밍 언어를 위한 고유의 기능을 제공하기도 한다
  - 구문 강조(syntax highlighting)
  - 자동 완성
  - 자동 들여쓰기
  - 코드나 문서 상용어구 지원
  - 관련 도움말 시스템
  - IDE 기능(컴파일, 디버그 등)

### 생산성

- 윈도우 메모장 유틸리티를 소스코드 편집에 사용하는 것

  - 삽 대신 티스푼을 사용하는 것과 별반 차이가 없다
  - 단순 타이핑, 잘라 붙이기만으로는 충분하지 않다

- 어떤 에디터는 일반적인 작업을 효율을 올리는 데 도움을 준다
  - 에디터가 자동으로 템플릿을 제공하는 경우
    - 클래스와 모듈 이름(파일 이름에서 도출된)이 채워져 있다
    - 여러분의 이름과 저작권 선언
    - 해당 언어의 프로그램 뼈대(생성자와 소멸자 선언)
  - 들여쓰기를 자동으로 해주는 경우
  - 코드를 자동으로 정렬해주는 경우 - 중괄호를 입력한 다음 줄바꿈을 하면 자동으로 들여쓰기를 해준다

### 여기에서 어디로 가나

- 나는 여러 개의 에디터에서 기본적인 기능만 사용한다
  - 강력한 에디터 하나를 골라서 그걸 제대로 익혀라
- 선호하는 에디터가 있긴 한데, 그 기능을 모두 사용하진 않는다
  - 그걸 배워라. 입력해야 하는 키 개수를 줄여라
- 선호하는 에디터가 있고 가능하다면 그걸 사용한다
  - 이미 하는 작업 외에 좀 더 많은 작업에 사용하도록 확장해 보라
- 윈도우 메모장이 최고다
  - 스스로가 행복하고 생산적이라면 그걸 사용해라. 하지만 스스로가 에디터 선망에 걸릴 수 있다는 생각이 들면 재평가할 필요가 있을 것이다

## 17. 소스코드 관리

- 우리는 `UNDO`로 몇 분전에 발생했던 일을 취소할 수 있다
- 하지만 실수가 지난주에 발생했고 그 이후로 컴퓨터를 열번 껏다 켰다면 어떨까?
- 소스코드 관리 시스템은 일종의 거대한 UNDO 키와 같다
  - 프로젝트 전체를 커버하는 타임머신이다
- 소스코드 관리 시스템 혹은 좀 더 넓은 의미의 형상 관리 시스템은 소스코드나 문서 관련의 모든 변화를 기억한다
  - 더 좋은 것들은 컴파일러나 OS 버전까지도 기억할 수 있다
- 적절히 설정된 소스코드 관리 시스템을 쓰면 소프트웨어의 이전 버전으로 언제든 되돌아갈 수 있다
- 어떤 제품들에서는 두 사람 이상의 사용자가 동일한 파일들에 대해 동시에 작업을 할 수 있다
  - 심지어는 하나의 파일을 동시에 수정할 수도 있다
  - 파일들을 저장소로 다시 보낼 때 시스템이 이 수정사항들을 합쳐준다

> Tip 23. 언제나 소스코드 관리 시스템을 사용하라

- 혼자서 한 주짜리 프로젝트를 진행하는 경우일지라도
  - 나중에 버리기로 한 프로토타입일지라도
  - 심지어 여러분이 작업하는 것이 소스코드가 아닐지라도
  - 모든 것이 소스코드 관리 아래 있도록 하라
  - 각종 문서, 전화번호 목록, 번더에게 보내는 메모, 빌드와 릴리스 과정, 작은 셸 스크립트 까지 모두 다
- 우리(실용주의 프로그래머)는 타이핑하는 거의 모든 것에 대해 일상적으로 소스코드 관리 시스템을 사용한다

### 소스코드 관리와 빌드

- 전체 프로젝트를 소스코드 관리 시스템 아래에 두면, 제품(product) 빌드가 자동화되고 그것을 반복할 수 있다
  - 프로젝트 빌드 매커니즘은 저장고에서 최신의 소스를 자동으로 가져올 수 있다

### 하지만 우리팀은 소스코드 관리 시스템을 사용하지 않는다면

- 스스로 부끄러워해야 한다

### 대표적 소스코드 관리 시스템

- CVS
- Subversion
- Git

### 관련 항목

- 직교성
- 일반 텍스트의 힘
- 결국은 모두 글쓰기

## 18. 디버깅

- 아무도 완벽한 소프트웨어를 작성하지 못하기 때문에, 하루의 대부분을 디버깅하는 데 보낼 것이라는 건 기정사실이다
- 디버깅에 관련된 몇 가지 문제를 살펴보고 찾기 힘든 버그를 찾아내는 일반적인 전략을 몇 가지 알아보도록 하자

### 디버깅의 심리

- 디버깅은 단지 `문제 해결`이라는 사실을 포용하고, 그 방식으로 공략하라
- 버그를 만든 사람을 찾아내고 비난하기 보다 문제를 고치는데 집중하자

> Tip 24. 비난 대신 문제를 해결하라

- 버그가 여러분의 잘못인지 다른 사람의 잘못인지는 그리 중요한 게 아니다
  어쨌거나 그 버그는 여러분의 문제로 남는다

### 디버깅 사고방식

> Tip 25. 디버깅을 할 때 당황하지 마라

- 마감일에 가깝거나 버그의 원인을 찾고 있는 동안 신경질적인 상사나 클라이언트가 여러분을 바짝 감시하고 있다면 당황하기 쉽다
  - 하지만 한 발짝 뒤로 물러나서 무엇이 자신으로 하여금 버그가 있을 거라고 생각하게 하는지, 그 증후의 원인이 무엇일지 실제로 생각해보는 것이 정말 중요하다
- 버그를 목격 후 '그럴 리가 없는데'로 시작하지 마라. 분명히 그런 일은 일어날 수 있으며, 실제로도 일어났기 때문이다
- 디버깅을 할 때 근시를 조심하라
  - 표면에 보이는 증상만 고치려는 욕구에 저항하라
  - 실제 문제는 여러분이 관찰하고 있는 것에서 몇 단계 떨어져 있고, 또 다른 여러 가지와 연관되어 있을 확률이 다분하다
  - 항상 근본적인 원인을 발견하려고 노력하고, 그 문제의 특정한 증상만 고치려고 하지 말라

### 어디에서 시작할까

- 컴파일러의 경고 확인
- 관찰을 정확히
- 자세한 정보를 충분히 얻기 위해서는 해당 버그를 보고한 사용자가 실제로 시연하는 것을 지켜볼 필요도 있다
- 그래픽 앱 사례
  - 보고자 : 특정 붓으로 그리면 멈춘다
  - 프로그래머 : 아무런 문제가 없다
  - 보고자 : 브러시 툴을 선택 후 우상단에서 좌하단으로 한 획을 그으니 멈추었다
- 교훈
  - 처음에 받은 자료 이상을 얻기 위해서 버그를 보고한 사용자를 인터뷰할 필요도 있다
  - 인공 테스트는 애플리케이션을 충분히 테스트하지 못한다
    - 경계 조건과 실제 최종 사용자 사용 패턴 모두를 철저히 테스트해야 한다
      - '가차 없는 테스트' 참고
- 버그 재연
  - 버그를 고치는 최선의 첫 단계는 그 버그를 재현할 수 있게 만드는 것이다
  - 만약 재현할 수 없다면 그 버그를 고쳤다는 것을 알 수 있겠는가?
  - 버그가 출현하는 시점까지 열다섯 단계를 거쳐야 한다면 버그 고치기는 훨씬 더 어렵다
  - 때로는 버그가 드러나는 환경을 다른것들로부터 분리 시킴으로써 어떻게 고쳐야 할지에 대한 통찰을 얻을 수도 있다
  - '유비쿼터스 자동화' 참고

### 디버깅 전략

- 무슨일이 벌어지고 있는지 안다고 스스로 생각한다면, 이번에는 프로그램은 어떻게 생각하는지 알아내야 할 차례다

#### 데이터를 가시화라라

- 프로그램이 뭘 하는지 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 잘 살펴보는 것이다

  - 가장 단순한 예는 출력 텍스트나 GUI 대화상자의 필드, 리스트로 구현된 '변수 이름 = 자료값' 접근법이다

- 하지만 데이터와 데이터들 사이에 존재하는 모든 상호관계를 시각화할 수 있는 디버거를 사용하면 자신의 데이터에 대해 훨씬 더 깊은 통찰을 얻을 수 있다

#### 트레이싱(tracing, 추적)

- 디버거는 일반적으로 프로그램의 현재 상태에 주목한다
  - 그러나 때로는 그 이상이 필요하기도 하다
- 시간에 따라 프로그램이나 데이터 구조의 상태가 변하는 것을 볼 필요가 생기기도 한다
- 스택 트레이스는 단지 여기에 어떻게 도달했는지를 말해줄 수 있을 뿐이다
  - 이 호출 연쇄 이전에 여러분이 무엇을 하고 있었는지는 말해줄 수 없다
- 트레이싱 구문은 '여기까지 도달'이나 'x=2' 등의 화면 혹은 파일에 출력하는 작은 진단용(diagnostic) 메시지를 일컫는다
  - IDE 형태의 디버거에 비하면 원시적인 기법이긴 하지만, 디버거가 진단할 수 없는 몇 가지 종류의 에러를 진단하는 데 특별히 효과적이다
- 트레이싱은 동시 프로세스, 실시간 시스템, 이벤트 기반 애플리케이션 등, 시간 자체가 중요한 요소가 되는 시스템에서 매우 귀중하다
- 트레이스 메시지는 규칙적이고 일관된 형식이어야 한다

#### 고무 오리

- 상대방은 여러분의 어깨 너머로 화면을 바라보면서 자기 머리를 계속 끄덕인다(마치 고무 오리가 욕탕 안에서 아래 위로 까닥이는 것처럼).
  - 그 사람은 말 한다미 할 필요가 없다
- `코드가 무엇을 해야하는지 차근차근 설명해 나가는 단순한 행위` 그 자체가 문제를 화면에서 뛰쳐나와 스스로 드러나게 하기도 한다
- 누군가에게 문제를 설명하게 되면 혼자 코드를 살펴볼 때는 당연히 여기고 지나갈 것을 명시적으로 이야기해야 한다
  - 이런 가정들 몇 가지를 말하면, 문제에 대한 새로운 통찰을 얻을 수 있다

#### 제거 과정

- 대다수의 프로젝트에서 디버깅하는 코드에는 아마도 자신의 코드와 프로젝트 팀 소속 다른 사람들의 애플리케이션 코드, 써드파티 제품들(데이터베이스, 네트워크, 그래픽 라이브러리, 특화된 커뮤니케이션이나 알고리즘 등등)과 플랫폼 환경(운영체제, 시스템 라이브러리, 컴파일러)이 뒤섞여 있을 것이다
- OS, 컴파일러 혹은 써드파티 제품에 버그가 있을 수도 있지만 처음부터 그런 생각을 하진 말라
  - 개발하고 있는 애플리케이션 코드에 버그가 존재할 가능성이 훨씬 더 크다
- 애플리케이션 코드가 라이브러리를 잘못 호출하고 있다고 가정하는 것이 라이브러리 자체에 문제가 있다고 가정하느 것보다 일반적으로 득이 된다
- 만약 써드파티 제품에 문제가 있다고 하더라도, 버그 리포트를 제출하기 전에 여전히 자신의 코드를 제거해야만 한다

> Tip 26. 'select(써드파티 제품)'는 망가지지 않았다

### 놀람의 요소

- 어떤 버그로 놀라게 될 때(어쩌면 그건 불가능해 라고 중엉거리게 될 때), 애지중지 믿고 있던 진실들을 재평가해야만 한다
- 여러분이 정말 완벽하다고 알고, 버그의 원인이라고 생각할 수조차 없는 바로 그 연결 리스트 루틴에서, 모든 경계 조건을 테스트 했던가?
  - 수년간 사용하고 있어서 여전히 버그가 있을 가능성이 없는 그런 코드는 어떤가?
  - 버그가 있지는 않았을까?
- 뭔가 잘못될 대 놀라는 정도는 실행되는 코드에 갖는 신뢰와 믿음의 정도에 정비례한다
- '안다고' 해서 대충 얼버무려 지나치지 마라. 그것을 증명하라. 이 맥락 안에서, 이 데이터로, 이 경계 조건 하에서 증명하라

> Tip 27. 가정하지 마라. 증명하라

- 놀라운 버그를 마주치면, 단순히 고치는 것을 넘어서 왜 이 실패가 더 일찍 발견되지 않았을까 생각해 볼 필요가 있다
- 버그를 미리 잡을 수 있도록 단위 테스트나 다른 테스트를 수정할 필요가 있는지 고려하라
- 버그가 발생하기 전에 이미 몇 단계를 거쳐 불량 데이터의 결과로 나왔다면, 이 루틴 속에서 매개 변수 검사를 좀 더 낫게 했더라면 그 문제를 더 일찍 분리해낼 수 있지 않았을지 살펴보라
- 이런 작업을 하는 중, 동일한 버그가 있을 여지가 있는 다른 코드가 있는가? 그것들을 찾아서 고쳐야할 때는 바로 지금이다
- '뭐가 일어나든지 간에' 다시 발생하면 그 사실을 알 수 있도록 하라
- 이 버그를 고치는 데 긴 시간이 걸린다면 왜 그런지 자문하라
  - 다음번에는 이 버그를 좀 더 쉽게 고칠 수 있도록 할 수 있는 뭔가가 있을까?
  - 더 나은 테스팅 훅을 만들어 넣거나, 로그 파일 분석기를 작성할 수도 있다
- 마지막으로, 만약 버그가 누군가 내린 잘못된 가정의 결과라면, 이 문제를 전체 팀과 함께 토론하라
  - 한 사람이 오해했다는 것은 여러 사람이 그럴 수 있다는 이야기다

### 디버깅 체크 리스트

- 보고된 문제가 내제하는 버그의 직접적 결과인가 아니면 단순히 증상일 뿐인가?
- 버그가 정말로 컴파일러에 있나? OS에? 혹은 여러분 코드에 있나?
- 이 문제를 동료에게 상세히 설명한다면 어떻게 말하겠는가?
- 의심가는 코드가 단위 테스트를 통과한다면, 테스트는 충분히 완전한 것인가?
  - 이 데이터로 단위 테스트를 돌린다면 무슨 일이 생기는가?
- 이 버그를 야기한 조건이 시스템의 다른 곳에도 존재하는가?

### 관련 항목

- 단정적인(assertive) 프로그래밍
- 우연에 맡기는 프로그래밍
- 유비쿼터스 자동화
- 가차 없는 테스트

## 19. 텍스트 처리

- 기본 도구 세트가 처리하지 못하는 어떤 변경을 다루어야 하는 경우가 가끔 있다
  - 범용 텍스트 처리도구가 필요한 것이다
- e.g. 동일 프로그램을 서로 다른 언어로 구현
  - C언어 : 150줄
  - 펄 : 17줄

> Tip 28. 텍스트 처리 언어를 하나 익혀라

- 텍스트 러리 언어의 적용 범위가 넓다는 것을 보여주기 위한 샘플 몇 가지

#### 데이터베이스 스키마 관리

- 펄 스크립트가 데이터베이스 스키마 정의가 들어가 있는 일반 텍스트 파일을 받아서 거기에서 다음의 것들을 생성해 낸다
  - 데이터베이스를 만드는 SQL 명령문
  - 데이터 사전을 채워 넣는 데이터 파일들
  - 데이터베이스를 액세스하느 C 코드 라이브러리
  - 데이터베이스 무결성(integrity)을 확인하는 스크립트
  - 스키마 설명과 도해를 담은 웹 페이지
  - 스키마의 XML 버전

#### 자바 속성 액세스

- 외부 클래스가 메서드를 통해서만 객체의 속성을 get/set 하도록 액세스하는 것은 좋은 객체지향 스타일이다
- 그렇지만 속성이 클래스 내에서 단순한 멤버 변수로 되어 있는 일반적인 경우, 각 변수에 대해 get/set 메서드를 일일이 만드는 것은 지겹고 기계적인 일이다
- 우리는 소스파일을 수정해서 적절히 플래그가 달린 모든 변수에 대해 올바른 메서드 정의를 삽입하는 펄 스크립트를 만들었다

#### 테스트 데이터 생성

- 테스트 데이터가 여러 개의 파일에 서로 다른 포맷으로 흩어져 있는데, 이것들을 함께 조립해서 관계형 데이터베이스에 넣기 적절한 형태로 변환해야 했다
- 펄은 이 작업을 수 시간 내에 마쳤다. 그리고 이 과정에서 원본 데이터에 있던 일관성 오류를 찾아냈다

#### 서적 집필

- 우리는 책에 나온 코드면 일단은 테스트된 것이어야 한다는 점을 중요하게 생각한다
- 이 책에 나온 코드는 대부분 테스트된 것이다
- 책을 포맷할 때 비교적 간단한 스크립트를 호출해서 그 스크립트는 소스 파일에서 이름이 붙은 특정 부분을 추출하고, 구문 강조 하고, 결과를 우리가 사용하는 조판(typesetting) 언어로 변환해 준다

#### C에서 오브젝트 파스칼 인터페이스로

- 펄 스크립트로 C헤더 파일을 해석해서 파스칼 인터페이스로 변환해 주는 스크립트를 만들었다

#### 웹 문서 생성

- 많은 프로젝트 팀들이 자신의 문서를 내부 웹사이트에 올려놓는다
- 우리는 데이터베이스 스키마, C나 C++ 소스파일, 기타 프로젝트 소스를 분석해서 HTML 문서를 만드는 펄 프로그램을 여럿 작성했다
- 또한, 문서를 표준 머리말과 꼬리말로 감싸서 웹사이트로 넘기는 데에 펄을 사용하기도 한다

- 우리가 알고 있는 언어들보다 텍스트 처리 언어로 구현하는 것이 더 간단하다
  - 이 언어들로 코드 생성기를 간단히 작성할 수 있는데, 이는 다음 항목에서 알아보자

### 관련 항목

- 중복의 해악

---

## 20. 코드 생성기

- 목공들은 똑같은 걸 반복해서 마나들어야 하는 작업을 할 때 지그나 형판을 사용하기도 한다
- 지그는 복잡성을 없애고, 실수할 확률을 줄이며, 장인이 품질에만 집중하도록 해준다
- 프로그래머인 우리도 비슷한 상황을 자주 접한다
  - 똑같은 기능을 그러나 좀 다른 맥락에서 필요로 한다
  - 같은 정보를 다른 여러 곳에서 반복해야 할 때가 있다
  - 단지 반복적이 타이핑 회수를 줄여서 수근관증후군(carpal tunnel syndrome, 손목터널증후군)에서 우리 자신을 보호해야할 이유도 있다
- 일단 만들기만 하면 프로젝트의 전 기간에 걸쳐 거의 아무런 추가비용 없이 사용할 수 있다

> Tip 29. 코드를 작성하는 코드를 작성하라

- 코드 생성기에는 두 가지 유형이 있다
  - 1. 수동적 코드 생성기는 결과를 내기 위해 한 번만 실행된다
  - 2. 능동적 코드 생성기는 코드 생성이 필요할 때 마다 작동한다
    - 능동적 코드 생성기가 만든 코드는 일회용이라서 언제든지 코드 생성기가 다시 만들어 낼 수 있다
    - 종종 어떤 형태의 스크립트나 컨트롤 파일을 읽어서 결과물을 만들어 낸다

### 수동적 코드 생성기

- 수동적 코드 생성기는 타이핑을 줄여준다
- 수동적 코드 생성기는 기본적으로 몇 개의 입력에서 주어진 출력을 생성하는 매개 변수화된 템플릿이다
- 여러분은 다른 여타 파일과 마찬가지로 그 결과물을 편집하고 컴파일하고 소스를 관리할 것이다. 그것의 출처는 잊혀진다
- 수동적 코드 생성기의 용도
  - 새 소스 파일 생성
    - 기본적으로 들어가는 코드를 만들어준다
  - 프로그래밍 언어간 일회용 변환을 수행하기
    - troff -> LATEX, 90% 정확도, 나머지 10%는 수작업으로 고침
  - 런타임에 계산하기엔 비용이 많이 드는 참조 테이블과 여타 자원을 생성하기
    - 그래픽 시스템 중 상당수는 삼각함수를 매번 계산하는 대신 사인과 코사인 값을 미리 계산해 준 테이블을 사용했다
    - 이런 테이블으 대개 수동적인 코드 생성기로 만든 다음 소스로 복사해 넣었다

### 능동적 코드 생성기

- 수동적 코드 생성기는 단지 편하려고 사용하는 반면, 능동적 코드 생성기는 DRY 원칙을 따르고 싶다면 필수적으로 써야 하는 것이다
- 어떤 지식을 단 하나의 형태로만 만들어 놓고 애플리케이션이 필요로 하는 온갖 형식으로 변환할 수 있다
  - 이렇게 만들어진 형식들은 언제든 버릴 수 있고, 필요할 때마다 코드 생성기가 만들어 내기 때문에, 이것은 중복이 아니다
- 자신이 별개의 두 환경을 오가며 함께 작업한다는 사실을 알아차릴 때마다, 능동적 코드 생성기를 사용해 보면 어떨지 고려해보아야 한다
- 데이터베이스 애플리케이션을 만들고 있는 경우

  - 이 경우, 여러분이 다루어야 할 환경은 데이터베이스와 그 데이터베이스에 접근해 사용해야 하는 프로그래밍 언어 두 개다
  - 스키마를 가져다 구조체들의 소스코드를 만드는 데 사용한다
  - 이제 스키마가 변경될 때마다 그 스키마에 접근하기 위해 사용되는 코드 또한 자동적으로 변경된다
  - 이런 방식은 코드 생성을 빌드 과정 자체의 일부로 만들어 두었을 대에만 효과가 있다

- 코드 생성기를 통해 여러 환경을 통합하는 다른 예
  - 한 애플리케이션에서 여러 다른 프로그래밍 언어가 사용되는 경우
  - 데이터 구조, 메시지 형식, 필드 이름 등등의 모든 코드 기반이 공통으로 가져야 하는 정보가 있어야 할 것이다
  - 이런 정보를 중복시키지 말고, 코드 생성기를 사용하라

### 코드 생성기가 꼭 복잡할 필요는 없다

- 능동적이니 수동적이니 하는 이야기들 때문에 코드 생성기란 복잡한 것이라는 인상을 가졌을지도 모르나 꼭 그렇지는 않다
- 가장 복잡한 부분은 입력 파일을 분석하는 일을 하는 파서다
- 입력 형식을 단순하게 만들면, 코드 생성기도 단순해진다

### 코드 생서익가 꼭 코드를 생성해야할 필요는 없다

- HTML, XML, 일반 텍스트 등등 원하는 어떤 결과물을 얻고자 할 대에도 코드 생성기를 쓸 수 있다
- 그리고 이런 결과물은 프로젝트의 다른 곳ㅇ데서 입력 파일로 사용될지도 모른다

### 관련 항목

- 중복의 해악
- 일반 텍스트의 힘
- 사악한 마법사
- 유비쿼터스 자동화
