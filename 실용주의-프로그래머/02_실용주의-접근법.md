# 2장. 실용주의 접근법

- 중복의 해악
  - 시스템을 통틀어 어떤 지식을 중복하지 말라고 경고
- 직교성
  - 하나의 지식을 여러 개의 시스템 컴포넌트에 걸쳐 쪼개 놓지 말라고 조언
- 가역성
  - 변화하는 환경에서 프로젝트를 분리하는 몇 가지 기법
- 예광탄
  - 요구사항을 모으고, 설계를 테스트하고, 코드를 구현하는 것을 동시에 가능케 하는 개발 스타일
  - 항상 적용가능한 것은 아니다. 그렇지 못할 때 -> 프로토타입과 포스트잇
- 프로토타입과 포스트잇
  - 아키텍처, 알고리즘, 인터페이스, 아이디어 등을 테스트하기 위해 프로토타입을 어떻게 사용할지 보게 될 것이다
- 도메인 언어
  - 스스로 구현할 수 있는 좀 더 현실적인 제안
- 추정
  - 제한된 시간과 자원
  - 어떤 일들이 얼마나 걸릴지를 아는 데 능숙해진다면 이런 희소성을 더 잘 극복할 수 있다

## 7. 중복의 해악

- 지식을 수집, 조직, 유지, 통제
- 명세서에 지식을 문서화, 실행 코드에서 그 지식이 생명을 갖고 살아나도록 한다
- 지식은 고정적이지 않다
- 프로그래머는 늘 유지보수 모드에 있다
  - 유지보수는 별개의 활동이 아니며, 전체 개발과정의 일상적인 부분이다
- 유지보수를 하려면, 애플리케이션에 들어 있는 지식의 캡슐들을 찾아내고 바꿔야 한다
  - 문제는 명세와 프로세스 그리고 프로그램을 개발하는 중에 지식을 중복해 넣기 쉽다는 것이다
    - 그러면애플리케이션이 선적되기 한참 전부터 유지보수의 악몽이 시작될 것이다
- 소프트웨어 신뢰성을 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY원칙이라고 부르는 것을 따르는 것 뿐
- DRY 원칙
  - 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현양식을 가져야 한다

> Tip 11. DRY - 반복하지 마라(Don't Repeat Yourself)

- 가장 중요한 도구 중 하나

### 어떻게 중복이 생기는가?

- 강요된(impose) 중복
  - 개발자들은 다른 선택이 없다고 느낀다
  - 환경이 중복을 요구하는 것처럼 보인다
- 부주의한 중복
  - 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다
- 참을성 없는 중복
  - 중복이 쉬워 보이기 때문에 개발자들이 게을러져서 중복을 하게 된다
- 개발자간의 중복
  - 한 팀에 있는(혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다

### 강요된 중복

- 때때로 중복을 강요당하는 것 같다
  - e.g. 여러 플랫폼을 지원해야 하는 경우
- 각각의 지식을 한 곳에 두면서 DRY 원칙을 따르는 기법들을 알아보자

#### 정보의 다양한 표현양식

- 클라이언트 사이드, 서버 사이드의 중복
  - 코드 생성기를 작성

#### 코드내의 문서화

- 나쁜 코드야 말로 많은 주석을 필요로 한다
- DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다
  - 그러지 않으면 지식을 중복하게 되며, 변경할 때마다 매번 코드와 주석 모두를 바꾸어야 한다
  - 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 주석이 전혀 없는 것보다 더 심각한 문제를 만들어 낸다
  - 주석 -> 385p. 결국은 모두 글쓰기

#### 문서화와 코드

- 여러분은 문서를 작성하고 나서 코드를 작성한다
- 마감일이 다가오기 시작하고, 긴박한 시기가 되면 문서의 갱신을 뒤로 미루기 쉽다는 걸 안다
- 사례. 문서 -> 테스트 자동 생성

#### 언어에 관한 문제

- 많은 언어가 소스코드에 상당한 양의 중복을 강요한다
  - 인터페이스 명서와 그것을 구현하는 코드 간에 인터페이스 정보가 중복
- 극복 사례
  - 헤더 파일을 자동으로 생성해서 그 필요를 감추기
- 헤더 파일과 구현 파일에 있는 주석
  - 함수 혹은 클래스 헤더 주석을 두 개 파일에 걸쳐 중복할 이유가 없다
  - 헤더 파일에는 인터페이스에 대한 사항을 기록하고, 구현 파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록하라

#### 부주의한 중복

- 때때로 중복은 설계 실수의 결과로 나타나기도 한다
- 유통 산업의 예
  - 트럭 : 유형, 흥록번호, 운전사
  - 배달 경로 : 경로, 트럭, 운전사
- 만약 운전사를 바꾸어야 한다면?

  - `트럭`과 `배달 경로` 모두 운전사를 포함하고 있다 -> 중복

- 개발 과정에서 성능상의 이유로 DRY 원칙을 위배할 수도 있을 것이다
  - 요령은 그 영향을 국소화하는 것이다
    - 바깥 세상에 DRY 원칙의 위배가 노출되지 않고, 단지 클래스 내의 메서들만이 좀 고생하면된다
    - 가능한 곳에서는 액세스 함수(getter)를 사용하라. 그러면 캐싱과 같은 기능을 나중에 추가하기가 더 쉬워질 것이다

#### 참을성 없는 중복

- 프로젝트 시간의 압박 -> 복사 후 필요한 만큼 약간 수정?
- 돌아가는 길이 지름길이다
- 당장 몇 초를 절약할 수 있을지라도, 나중에는 몇 시간을 잃게 될런지 모른다
- 참을성 없는 중복은 발견하지 쉽고 다루기도 쉬운 형태이지만, 나중의 고통을 피하기 위해서는 훈련이 필요하고, 미연에 시간을 투자할 의지가 있어야 한다

#### 개발자간의 중복

- 높은 차원의 해법
  - 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 그 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것
  - 이런 것들로 개발자 간의 중복 문제를 다루어라
  - 그렇지만 모듈 차원이라면 그 문제를 알아채기란 더욱 어렵다
  - 분명한 책임 영역으로 나뉘어지지 않는 공통 필요 기능이나 데이터는 여러 번 거듭 구현될 가능성이 있다
- 우리가 느끼기에 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것이다
  - 공통의 문제를 다루기 위한 토론장을 만들어라
  - 한 사람의 팀원을 프로젝트 사서가 되도록 임명하라
    - 그의 일은 지식 교환을 도와주는 것이다
  - 소스트리의 한 가운데에 유틸리티 루틴과 스크립트들이 저장될 수 있는 장소를 마련하라
    - 그리고 비공식적으로 혹은 코드 리뷰시 다른 사람의 소스코드와 문서를 읽도록 하라
    - 다른 사람의 것들을 기웃거리는 게 아니고, 거기서 배우는 것이다
- 다른 사람이 여러분의 코드를 들여다 본다고 해서 기분 나빠하지 말 일이다

> Tip 12. 재사용하기 쉽게 만들어라

- 여러분이 조성해야 할 환경이란 뭔가를 직접 만드는 것보다 기존의 것을 찾아내고, 또 재사용하기 쉬운 환경이다
  - 만약 그게 쉽지 않다면 사람들은 하지 않을 것이다
  - 그리고 만약 재사용에 실패한다면 지식 중복의 위험을 각오해야 한다

### 관련 항목

- 직교성
- 텍스트 처리
- 코드 생성기
- 리팩터링
- 실용주의 팀
- 유비쿼터스 자동화
- 결국은 모두 글쓰기

## 8. 직교성

- 확장하기 쉬운 시스템을 만드는 데 있어 직교성은 매우 중요한 개념이다

### 직교성이란

- 직교성은 기하학에서 빌려온 용어다
- 그래프의 축과 같이 두 직선이 직각으로 만나는 경우 직교한다고 말한다

  - 벡터의 입장에서 보면, 두 개의 선은 '독립적'이다
  - 두 선 가운데 하나의 방향으로 움직여도 나머지 선 위로 투영된 여러분의 위치는 변하지 않는다

- 컴퓨팅에서 이 용어는 일종의 독립성(independence)이나, 결합도 줄이기(decoupling)를 의미한다
  - 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다
- 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다
  - 데이터베이스에 영향을 주지 않으면서 인터페이스를 바꿀 수 있고,
  - 또한 인터페이스를 바꾸지 않으면서 데이터베이스를 교환할 수 있다
- 직교적인 시스템의 장점을 보기 전에 직교적이지 못한 시스템을 먼저 보도록 하자

#### 비직교적인 시스템

- 헬리콥터 조종 -> 하나가 다른 부분에 영향을 미침 -> 헬리콥터 조종은 직교적이지 않다

### 직교성의 장점

- 시스템의 컴포넌트들이 고도로 상호의존적인 경우, 특정 국지적 부분만 수정하는 방법이란 없다

> Tip 13. 관련 없는 것들 간에 서로 영향이 없도록 하라

- 우리는 자조적(self-contained)인 컴포넌트를 설계하기를 원한다
  - 독립적이며, 단일하고 잘 정의된 목적을 가진 컴포넌트
- 직교적인 시스템을 작성하면 두 가지 큰 장점이 있다
  - 생산성 향상
  - 리스크 감소

#### 생산성 향상

- 변화가 국소화 되서 개발 시간과 테스트 시간이 줄어든다
  - 상대적으로 작고, 자족적인 컴포넌트를 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다
  - 간단한 컴포넌트들은 설계하고, 코딩하고, 단위 테스트하고, 그러고는 잊어버릴 수 있다
  - 새로운 코드를 추가할 때마다 기존의 코드를 계속 바꾸어야 할 필요가 없다
- 직교적인 접근법은 재사용을 촉진한다
  - 컴포넌트들에 명확하고 잘 정의된 책임이 할당되어 있다면 애초의 구현자들이 미처 생각하지 못했던 방식으로 새로운 컴포넌트와 결합할 수 있다
  - 시스템이 더 느슨하게 결합되어 있을 수록 재설정하고 리엔지니어링하기 쉽다
- 직교적인 컴포넌트들은 결합하는 경우 꽤 미묘한 생산성 향상이 있다
  - 직교적일 때 결과물 M \* N, 겹치는 부분이 있으면 결과물은 그 이하일 것이다

#### 리스크 감소

- 감염된 코드는 격리된다
  - 문제가 있는 코드는 쉽게 도려내고 대체하기 쉽다
- 시스템이 잘 깨어지지 않는다
  - 어떤 부분을 골라서 약간 바꾸고 수리해도 거기서 생기는 문제점들은 그 부분에만 한정될 것이다
- 직교적인 시스템은 해당 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽기 때문에, 아무래도 더 많은 테스트를 하게 된다
- 써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되기 때문에 특정 벤더나 제품, 플랫폼에 덜 종속될 것이다

- 직교성의 원칙을 일에 적용할 수 있는 방법을 알아보자

### 프로젝트 팀

- 어떤 팀은 구성원들이 끊임없이 말다툼하고 서로 방해가 되는 반면
- 어떤프로젝트 팀은 얼마나 효율적인지, 모든 구성원들이 무엇을 할지 잘 알고 있으며, 또 전적으로 기여하고 있는지 본 적이 있는가?

- 이것은 종종 직교의 문제다
- 팀 내 업무가 겹치는 영역이 많다면 구성원들은 책임 영역에 대해 혼동하게 된다
  - 뭘 하나 바꾸려고 해도 그들 중 누구라도 영향을 받을 수 있기 때문에 전체 팀원이 모여야 한다
- 어떻게 팀을 조직해서 책임이 잘 정의되어 있고 중복이 최소화된 그룹으로 만들 것인가?
  - 간단한 답은 없다
  - 부분적으로는 프로젝트에 달려있고, 또한 잠재적인 변화 영역에 대한 여러분의 분석에 달려 있다
  - 또한 가용한 사람들에도 의존한다
- 우리는 애플리케이션에서 인프라를 분리하는 방식을 선호한다
  - 주된 인프라 컴포넌트 -> 데이터베이스, 컴니케이션 인터페이스, 미들웨어 레이어 등등
  - 서브팀을 할당한다
  - 애플리케이션 기능분할 역시 유사하게 나뉜다
  - 그러고 나서 현재의 가용 인원을 확인하고 조직을 적절하개 개편한다
- 프로젝트 팀 구조가 얼마나 직교성을 가졌는지 확인하는 간단한 방법
  - 요청된 개별 변화에 대한 토론에 참여할 사람이 많을 수록 직교성은 낮다

### 설계

- 레이어(계층)
- 전형적인 레이어 그림(그림 2.1)
  - 사용자 인터페이스
  - 데이터베이스 엑세스, 리포트 엔진, 비즈니스 로직
  - 애플리케이션 프레임워크(표준 C 라이브러리)
  - 운영체제
- GUI 패널의 단추 하나를 옮기는 것 때문에 데이터베이스 스키마가 변경되어서는 안 된다

### 툴킷과 라이브러리

- 써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴보기 바란다
- 라이브러리를 도입할 때에 이것이 여러분의 코드에 있어서는 안 될 변화를 강요하고 있지는 않은지 검토해 보라

### 코딩

- 코드를 작성하고 있다면 언제나 애플리케이션의 직교성을 떨어뜨릴 수 있는 위험에 노출되어 있다

#### 코드의 결합도를 줄여라

- 부끄럼타는 코드(shy code)를 작성하라
  - 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라
- 전역 데이터를 피하라
  - 코드가 전역 데이터를 참조할 때마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다
- 유사한 함수를 피하라
  - 디자인패턴의 전략 패턴을 사용하여 더 나은 구현을 할 수 없는지 고려해보기 바란다

### 테스트

- 직교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다
- 모듈이 자신만의 단위 테스트를 위한 테스트케이스를 갖고, 테스트가 정규 빌드 과정의 일부로 수행되어야 한다

### 문서화

- 직교성은 놀랍게도 문서에도 적용할 수 있다
- 내용과 표현이 두 축이 된다
- 정말 직교적인 문서라면 내용 변화 없이 표현을 극적으로 바꿀 수 ㅊ있을 것이다
- 현대의 워드 프로세서는 이를 도와주는 스타일시트와 매크로를 제공한다

### 직교적으로 살아가기

- 직교성은 DRY 원리와도 밀접한 관계가 있다
- 시스템 내부의 중복을 최소화시키고, 직교성은 시스템 컴포넌트 간의 상호의존도를 줄인다

### 관련 항목

- 중복의 해악
- 소스코드 관리
- 계약에 의한 설계
- 결합도 줄이기와 디미터 법칙
- 메타프로그래밍
- 단지 뷰일 뿐이야
- 리팩터링
- 테스트하기 쉬운 코드
- 사악한 마법사
- 실용주의 팀
- 결국은 모두 글쓰기

### 연습문제

- Split2가 더 직교성이 좋다(readNextLine이 없음)

## 9. 가역성

- 엔지니어는 문제에 대한 단순한 하나의 해결안을 좋아한다
- 불행이도 영원한 것은 없다. 시간이 지나면 어떤 것이든 변화한다
- 무언가를 구현하는 방법에는 여러 가지 길이 있고, 보통 하나의 솔루션에는 여러 벤더의 제품이 존재한다
- 많은 프로젝트 팀들이 프로젝트를 진행하면서 어쩔 수 없이 고통스럽게 그들의 근시안을 조금씩 수정하게 된다

### 가역성

- 이 책의 많은 주제들은 유연하고, 적응 가능한 소프트웨어를 만드는 방법에 대해 설명한다
- 이는 우리가 프로젝트 초기에 항상 최선의 결정을 내리는 것은 아니라는 점에서 매우 유용하다
- 클라이언트-서버 모델로 시작한 프로젝트
  - 클라이언트 서버를 독립형 버전으로 만들 때, 오래 걸린다면 가역성에 대해 다시 생각해보기 바란다
  - 마케팅 팀이 독립형 제품을 클라이언트-서버 혹은 n-티어 방식으로 설치하길 원한다면? 역시 어렵지 않아야 한다
- 결정이 돌에 새겨진 것이 아니라 해변가의 모래 위에 쓰인 글씨라 생각해 보자
  - 언제든 큰 파도가 글씨를 지워버릴 수 있다

> Tip 14. 최종 결정이란 없다

### 유연한 아키텍처

- 많은 사람들이 코드를 유연하게 유지하려고 노력한다
- 하지만 아키텍처, 배포, 벤더 통합 영역의 유연성에 대해서도 관심을 기울일 필요가 있다

- 설정파일만 변경하면 독립형, 클라이언트-서버, n-티어 모델 중 하나를 지원할 수 있도록 하는 방안을 미리 생각해 보라

### 관련 항목

- 결합도 줄이기와 디미터 법칙
- 메타프로그래밍
- 단지 뷰일 뿐이야

## 10. 예광탄

- 어둠 속에서 기관총을 쏘는 방법은 두 가지가 있다

  - 목표물이 정확히 어디에 있는지 확인하고 계산 쏜다
  - 예광탄을 쓴다

- 예광탄은 탄창의 일반 탄환들 사이에 일정한 간격으로 끼어있다

  - 예광탄이 발사되면 그 안에 인성분이 발화하여 빛의 궤적을 남긴다
  - 예광탄이 목표물을 맞힌다면 일반 탄환도 맞힐 것이다

- 사람들은 힘든 계산보다 예광탄을 좋아한다

- 프로젝트에서도 마찬가지다
  - 전에 만들어진 적이 없는 전혀 새로운 것을 만들고 있다면 더욱 그렇다
- 이슈
  - 요구사항이 막연할지도 모른다
  - 익숙하지 않은 알고리즘, 기술, 언어, 라이브러리들을 사용해야할지도 모른다

### 어둠 속에서 빛을 내는 코드

- 예광탕이 효과가 있는 까닭은 동일한 환경에서 발사되고 도달하는 시간이 짧아서 즉각적인 반응을 얻을 수 있다
- 상대적으로 비용이 적게 드는 방법이다
- 코딩에서도 요구사항으로 부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다

> Tip 15. 목표물을 찾기 위해 예광탄을 써라

- 예광탄 코드는 나중에 버리려고 만드는 것이 아니다
  - 그것은 계속 사용할 코드다
  - 예광탄 코드에도 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다
  - 단지 예광탄 코드에는 아직 완전한 기능이 들어있지 않을 뿐이다
  - 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 가까이 다가섰는지 확인할 수 있으며, 필요하다면 조정도 할 수 있다
- 예광탄 개발 방법은 점진적인 접근 방법이다
- 이와 대비되는 전형적인 방법은 일종의 거대 공학적 접근 방식이다

  - 코드는 모듈들로 분류되고, 각 모듈은 진공 상태에서 작성된다
  - 모듈을 조립해서 시스템의 하위 부품들을 만들고, 하위 부품들을 다시 조립해서 언젠가 전체 애플리케이션이 완성된다
  - 이 때가 돼서야 전체 애플리케이션을 사용자에게 보여주거나 테스트할 수 있다

- 예광탄 코드 접근 방법에는 여러 장점이 있다
  - 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다
  - 개발자들은 들어가서 일할 수 있는 구조를 얻는다
  - 통합 작업을 수행할 기반이 생긴다
  - 보여줄 것이 생긴다(데모)
  - 진전 상황에 대해 더 정확하게 감을 잡을 수 있다

### 예광탄이 언제나 목표물을 맞추는 것은 아니다

- 목표물이 맞을 때까지 조준을 옮겨야 한다

### 예광탄 코드 vs. 프로토타이핑

- 예광탄 코드와 프로토타이핑의 차이점
  - 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다
    - 어떤 개념을 구현해 보려고 시도할 때 대충 끼워 맞춘 것을 모두 버린 다음, 실험과정에서 얻은 교훈을 바탄으로 다시 코드를 만들게 ㅗ딘다
    - 예. GUI도구로 프로토타입을 만들고 사용자의 행동에 반응ㄹ을 보이는 정도에 필요하나 코드만 작성
      - 사용자가 화면 배치에 동의한 후에는 그 코드는 버리고 진짜 프로젝트용 언어를 사용해서, 이번에는 비즈니스 로직도 뒤에 채워넣어 새로 코드를 작성할 것이다
  - 프로토타이핑도 매우 유용한 방법이다
- 예광탄 코드의 접근 방법은 다른 종류의 문제에 대한 대응 방법이다
  - 단순하지만 동작은 하는 사용자 인터페이스로 구성된 예광탄을 만들 것이다
  - 일단 이렇게 애플리케이션의 모든 요소들을 이어붙이면, 사용자들과 개발자들에게 보여줄 프레임워크가 생긴다
- 첫 번째 예광탄 코드가 완성되었을 때 여러분은 시스템이 앞으로 그 방식 그대로 동작하라는 점을 안다
- 프로토 타입은 나중에 버릴 수 있는 코드를 만든다
- 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다
- 프로토타입을 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 수집으로 생각하면 되겠다

- 내 생각
  - 프토토타입 : 퍼블리싱만 한 페이지
  - 예광탄 : 컴포넌트로 구성된 페이지 + 일부 퍼블리싱

### 관련 항목

- 적당히 괜찮은 소프트웨어
- 프로토타입과 포스트잇
- 명세의 함정
- 위대한 유산

## 11. 프로토타입과 포스트잇

- 다양한 산업 분야에서 프로토타입을 이용하여 보다 구체적인 아이디어를 끌어내려 시도하고 있다
  - 프로토타이핑은 시렞 제품을 만드는 것에 비해 여러모로 저렴하기 때문이다
- 프로토타입은 반드시 코드로 작성해야할 필요는 없다
- 포스트잇은 작업흐름과 애플리케이션 로직과 같은 동직인 것들을 포로토타이핑해 볼 수 있는 훌륭한 도구다
  - 사용자 인터페이스는 화이트보드에 그려보거나, 페인트 프로그램, 인터페이스 빌더 등을 이용해 기능은 구현하지 않고 인터페이스만을 그려보는 방법으로 프로토타입을 만들 수 있다
- 당장 중요하지 않은 세부사항 등을 코드에서 무시할 수 있다
  - 예를 들어, GUI를 프로토 타이핑하고 있다면 정확하지 않은 결과나 데이터도 무방할 것이다
- 반대로 계산이나 성능 측면을 조사하고 있다면 아주 간단한 GUI를 만들거나 아에 GUI를 생략해도 괜찮다
- 하지만 만약 세부사항을 포기할 수 없는 환경이라면, 예광탄 스타일의 개발이 더 적절할 것이다

### 프로토타입의 대상

- 이전에 해본적이 없는 것
- 최종 시스템에 매우 중요한 것 등이 프로토타입의 대상이 된다
- 증명되지 않았거나, 실험적이거나, 의심이 가는 것, 심적으로 편하지 않은 것 모두가 프로토타이핑의 대상이 될 수 있다
- e.g.

  - 아키텍처
  - 기존 시스템애 추가할 새로운 기능
  - 외부 데이터의 구조 혹은 내용
  - 써드파티 도구나 컴포넌트
  - 성능 문제
  - 사용자 인터페이스 설계

- 프로토타이핑은 학습 경험이며, 프로토타입의 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다

> Tip 16. 프로토타입을 통해 학습하라

### 프로토타입을 어떻게 사용할 것인가?

- 프로토타입을 만들 때 무시해도 좋은 세부사항은 무엇인가?
  - 정확성: 적절히 가짜(dummy) 데이터를 사용할 수 있다
  - 완전성: 프로토타입은 어쩌면 미리 선정한 입력 데이터와 한가지 메뉴 항목에서만 작동하면 되기 때문에 제한된 기능만을 제공하기도 한다
  - 안정성: 에러 검사는 불완전할 수도 있고, 때론 완전히 무시될 수도 있다
    - 미리 정의된 방법대로 실행시키지 않는다면 와장창 망가지고 불꽃놀이를 보여주면서 타버릴 수도 있지만 괜찮다
  - 스타일: 프로토타입 코드는 주석이나 문서를 많이 만들지 않아도 된다
    - 프로토타입을 통한 경험의 결과로 문서를 많이 만들어 낼 수도 있겠지만, 프로토타입 자체에는 많은 문서를 많이 만들어 넣지 않아도 된다

### 아키텍처 프로토타이핑

- 많은 프로토타입들이 고려 중인 전체 시스템을 모델링하기 위해 만들어진다
- 예광탄과는 달리 프로토타입 시스템의 모듈이 꼭 기능을 가져야 하는 것은 아니다
- 아키텍처를 프로토타이핑할 때 코드를 작성하지 않고 화이트보드, 포스트잇, 인덱스카드 등을 사용해도 된다
- 프로토타입에서 기대하는 것은 전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이다

- 다음은 아키텍처 프로토타입에서 규명할 만한 사항이다
  - 주요 컴포넌트의 책임이 잘 정의되었고 적절한가?
  - 주요 컴포넌트 간의 협려관계가 잘 정의되었는가?
  - 결합도는 최소화되었는가?
  - 잠재적 중복을 찾아낼 수 있는가?
  - 인터페이스 정의와 제약 사항은 수용할만한가?
  - 각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가?
    - 모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?

### 어떻게 프로토타입을 사용하지 않을 것인가?

- 프로토타입 코드로 만들 때는 항상 모든 사람에게 여러분이 폐기처분할 코드를 작성하고 있다는 사실을 이해시켜야 한다
- 프로토타입은 그것이 프로토타입임을 모르는 사람들에게는 매우 매력적일 수 있기 때문이다
- 그러므로 코드는 폐기할 것이고, 불완전하며 완성할 수 없다는 사실을 분명히 주지시켜야 한다
- 나무 자동차를 타고 라시아워에 운전할 수 없다는 사실을 환기시키기 바란다
- 만약 여러분이 작업하는 환경이나 문화에서 프로토타입 코드의 목적이 잘못 해석될 가능성이 크다곡 느낀다면, 예광탄 접근 방식을 취하는 게 나을 것이다

### 관련 항목

- 고양이가 내 소스를 삼켰어요
- 소통하라!
- 예광탄
- 위대한 유산

## 12. 도메인 언어

- 컴퓨터 언어는 여러분이 문제에 대해 생각하는 방식과 의사소통에 대해서 생각하는 방식에 영향을 미친다
- 우리는 언제나 애플리케이션 도메인(프로젝트 용어사전 만들기를 권장하고 있는 '요구사항의 구렁텅이' 참고)의 어휘를 사용해서 코드를 작성하려고 노력한다
- 몇몇 경우, 한 차원 더 나아가서 실제로 그 도메인의 어휘, 문법, 의미론을 사용해서 프로그래밍하는 일이 가능할 때도 있다
- 어떤 시스템을 제안하는 사용자의 말을 듣다보면, 그들이 정확히 시스템이 어떻게 동작해야 하는지 우리에게 말해주는 경우도 있다
- 이 언어가 꼭 실행가능할 필요는 없다
  - 처음에는 단지 사용자의 요구사항을 잡아내는 명세로만 쓰여도 된다
  - 명세가 실행가능한 코드가 되는 것이다

> Tip 17. 문제 도메인에 가깝게 프로그래밍하라

- 더 높은 추상화 수준에서 작업함으로써 사소한 구현의 세부사항들을 무시하고 도메인의 문제들을 푸는 일에만 정신을 집중할 수 있다
  - 내 생각: 디자인패턴의 장점과 같다

### 소형 언어를 구현하기

- 구형언어를 구현하는 간단한 방법 : 파싱하기 쉬운 라인 중심 형식의 언어로 만드는 것
- 도메인에 꼭 맞는 에러 예시
  - 표준 범용 에러 메시지
    - 선언되지 않은 식별자 입니다
  - 소형 언어, 도메인 어휘를 이용해서 에러 메시지를 출력
    - "AB123"은 형식이 아닙니다. 알려진 형식은 ABC123, XYZ43B 입니다

### 데이터 언어와 명령형 언어

- 데이터 언어는 애플리케이션이 사용할 어떤 형식의 데이터 구조를 만든다
  - 환경 설정 정보를 표현하기 위해 쓰이는 경우가 많다
  - 전자 우편 sendmail 프로그램
- 명령형 언어는 한발 더 나아간다. 실제로 실행되며, 문장, 제어 구조체 등을 가질 수 있다
- 내 생각
  - 아직 무슨 내용인지 잘 모르겠다

### 독립 언어와 내장 언어

### 쉬운 개발 아니면 쉬운 유지보수?

- 자칫 암호처럼 보일 가능성이 있다
- 현재의 고통을 참고 더 복잡하지만 가독성 좋은 언어를 채택하는 편이 더 좋을 것이다

### 관련 항목

- 메타프로그래밍

## 13. 추정

- 여러분이 추정에 익숙하다면 답할 수 있는 문제
- 추정에 대한 지식을 배운 후에 경험을 통해 추정 능력을 계발하고, 어디에 크기에 대한 직관적 느낌을 적용해야 할지를 알게 된다면, 무언가의 가능성을 가늠할 수 있는 마술과 같은 능력을 발휘할 수 있게 될 것이다

> Tip 18. 추정을 통해 놀람을 피하라

### 얼마나 정확한 것이 충분히 정확한 것인가?

- 누군가 추정치를 물었을 때
  - 매우 높은 정확도의 답을 요구하는가?
  - 아니면 단순히 큰 그림만을 요구하는가?
- 파이(π)를 추정
  - 학교: 3.14
  - 나사: 소수점 이하 열두 자리까지는 고려해야 한다
- 사용하는 단위가 결과의 해석에 차이를 가져온다
  - 130일 정도 vs 대략 6달
- 추정의 단위
  - 1~15일 : 일
  - 3~8주: 주
  - 8~30주: 달
  - 30주 이상: 추정치를 말하기 전에 다시 한번 생각해 보라

### 추정치는 어디에서 오는가

- 기본적인 추정 기술
  - 이미 그 일을 해본 사람에게 물어보라

#### 무엇을 묻고 있는지 이해하자

- 어떤 종류의 추정이건 연습의 첫 단계는 상대방이 무엇을 묻고 있는지에 대해 이해하는 것이다
- 도메인 범위에 대해 감을 잡을 필요가 있다
- 추정을 하기 전에 미리 생각을 하는 습관을 기르는 것이 좋다
- e.g. 교통사고가 일어나지 않고, 연료가 떨어지지 않는다면 20분 이내에 도착할 겁니다

#### 시스템의 모델을 만들어보라

- 대략적이고 꾸밈없는 모델을 만들어보라
  - 만약 응답시간을 추정하고 있다면 서버와 서버에 도달하는 몇 종류의 트래픽을 포함한다
  - 프로젝트에서 모델은 디딤대가 되어줄 뿐만 아니라 시스템을 어떻게 구현해야 할지에 대한 대략적인 그림을 제공해 줄 것이다

#### 모델을 컴포넌트로 나누어라

- 모델 -> 컴포넌트로 분해
- 컴포넌트는 결과에 합산될 단일 값을 내어준다
  - 매개변수
- 이 단계에서는 일단 각 매개변수를 규명하면 된다

#### 각 매개 변수에 값을 주어라

- 매개변수에 값을 준다
- 약간의 부적확함이 있을 수 있다
- 적용해 볼만한 기술: 결과에 큰 영향을 미치는 매개변수가 무엇인지를 규명하고, 이 매개 변수의 값들을 최대한 정확히 산출해내는 것이다

#### 답을 계산하라

- 문제가 매우 단순한 경우 추정치가 하나의 답을 갖게 될 것이다
  - 나는 도심에서 다섯 블록을 15분에 걸을 수 있어
- 하지만 시스템이 복잡해짐녀 여러 답에 대해 양다리 거맃기를 하고 싶어질 것이다
  - 중요 매개 변수들의 값을 변경시켜 가면서 여러 번 계산을 해보고, 이 가운데 어떤 것이 모델과 잘 들어 맞는지 찾아내라
  - 이때 스프레드시트는 큰 도움이 된다
- 계산 단계에서 언뜻 이상해 보이는 답을 얻을 수도 있다
  - 이때 이 값을 너무 쉽게 버리면 안 된다
  - 만약 계산이 정확하다면, 아마도 문제를 잘못 이해했거나 모델이 잘못되었을 것이다
  - 이는 귀중한 정보다

#### 추정치를 기록하는 용기

- 여러분이 계산한 추정치를 기록해 놓고, 이 값이 실제 결과에 얼마나 가까운지를 평가해 보는 것은 좋은 생각이다
- 추정치가 잘못되었어도 움츠리거나 도망가지 마라.
  - 왜 여러분의 추측과 실제 값이 달라졌는지 원인을 찾아야 한다
    - 실제 문제와 맞지 않는 매개변수를 선택했을 수도 있다
    - 아니면 모델 자체가 잘못되었을 수도 있다
    - 원인이 무엇이든, 시간을 들여 이를 규명하라. 다음 추정치는 훨씬 나아질 것이다

### 프로젝트 일정 추정하기

- 프로젝트 일정을 정할 수 있는 유일한 방법은 진행하는 해당 프로젝트를 경험하는 것뿐이란 사실을 알게 된다
- 다음과 같은 단계를 반복하는 점증적 개발을 연습한다면 가능하다

  - 요구사항 체크하기
  - 위험 분석하기
  - 설계, 구현, 통합
  - 사용자와 함께 검증하기

- 프로젝트 초기
  - 초기 기능의 구현과 테스트를 마친 후 이를 첫 번째 반복의 끝으로 삼아라
  - 이 경험에 기반해 반복의 횟수와 각 반복에서 무엇을 할지에 대한 초기 추측을 다듬을 수 있다
  - 이런 정제는 각 반복이 끝날 때 마다 나아질 것이고, 일정에 대한 확신도 이와 함께 증가할 것이다

> Tip 19. 코드와 함게 일정도 반복하며 조정하라

### 누군가 추정에 대해 물으면 무엇이라 대답해야 할까?

- 저자라면 "나중에 전화드릴께요"라 말할 것이다
- 프로젝트 도중 숨을 고르고, 잠시 시간을 내어 이번 항목에서 기술한 단계를 밟아나간다면 더 정확한 추정치를 알려줄 수 있다
- 자판기 앞에서 말한 추정치는 커피와 마찬가지로 여러분에게 해를 끼칠 것이다

### 관련 항목

- 알고리즘의 속도
