# 5. 구부러지거나 부러지거나

- 현대의 빠른 변화속도에 맞추기 위해서는 가능한 느슨하고 유연한 코드를 작성하기 위해 노력해야 한다
  - 유연성, 적응성
- 이 장에서는 되돌릴 수 있는 의사 결정을 내릴 수 있는 구체적인 방법에 대해 설명한다
- 결합도 줄이기(decoupling)와 디미터 법칙
  - 모듈간의 의존 정도를 의미하는 결합도에 대해 살펴볼 필요가 있다
  - 서로 다른 개념들을 분리하여 결합도를 줄이는 방법에 대해 알아본다
- 메타프로그래밍
  - 유연함을 유지하는 좋은 방법 : 가능한 적은 양의 코드를 작성하는 것
  - 세부사항을 완전히 코드 밖으로 옮기는 방법에 대해 설명한다
    - 세부사항을 안전하고도 쉽게 변경할 수 있다
- 시간적 결합
  - 결합도와 관련하여 시간을 두 측면에서 살펴본다
  - 유연하고 싶다면 시간상의 결합을 피해야 한다
- 단지 뷰일 뿐이야
  - 뷰와 모델의 결합도를 줄이는 방법을 설명한다
- 칠판
  - 모듈들이 데이터를 동기적, 비동기적으로 교환할 수 있는 만남의 장소를 마련해 줌으로써 모듈간 결합도를 획기적으로 줄이는 기술

## 26. 결합도 줄이기와 디미터 법칙

- '직교성'과 '계약에 의한 설계'에서 부끄럼 타는(shy) 코드를 작성하는 것이 이롭다고 했다
- '부끄럽 타는'이란 자신을 남에게 속속들이 드러내지 말고, 너무 많은 사람과 상호작용하지 말라는 두 가지 의미를 모두 내포한다
  - 스파이, 혁명가들은 종종 세포(cell)라 불리는 작은 그룹으로 조직을 만든다
  - 각 세포의 구성원은 같은 세포에 속한 구성원만 알 수 있으며, 다른 세포에 누가 있는지에 대해서는 전혀 모른다
  - 하나의 세포가 발각된다 하더라도, 다른 세포에 있는 사람들은 안전하다
  - 세포 간의 상호작용을 제거함으로써 모두를 보호하는 것이다
- 코드를 세포(모듈, module)로 구성하고, 이들 간의 상호작용을 제한하라
  - 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다

### 결합도 줄이기

- 얼마나 많은 모듈과 상호작용하는지, 어떻게 상호작용을 하는지에 대해 주의를 기울일 필요가 있다
- 집 리모델링
  - 주 계약자와 계약
  - 주 계약자는 직접 벽돌을 나르지 않고 각각의 역할을 맡은 하도급자와 다시 계약
  - 여러분은 하도급자와 직접 부딛힐 일도, 이들로 인해 골머리 썩을 일도 없게 된다
- 소프트웨어에서도 이와 같은 모델을 따르기를 권한다
  - 어떤 객체에 특정 서비스를 요청했을 때 이 요청을 바로 처리해주기 바란다
  - 제 3의 객체를 넘겨받아 이미 요청한 서비스를 가지고 이러쿵저러쿵 하고 싶지는 않을 것이다
- 예. 과학 기록 정보를 그래프로 표현하는 클래스 작성
  - 데이터 기록기는 세계 곳곳에 분산
    - 각 기록기 객체는 객체가 위치한 곳의 위치와 시간대를 알려주는 장소 객체를 가지고 있다
  - 사용자가 기록기를 선택해서 올바른 시간대가 표시된 데이터 그래프를 보게 하고 싶다면, 다음과 같은 코드를 작성할 수 있을 것이다

```java
// bad
public void plotDate(Date aDate, Selection aSelection) {
  TimeZone tz = aSelection.getRecorder().getLocation().getTimeZone();
  // ...
}
```

- 하지만 이렇게 되면 그래프를 그리는 루틴이 불필요하게 Selection, Recorder, Location 이라는 3개의 클래스와 결합되게 된다
  - 이런 방식으로 코딩하면 우리의 클래스가 의존하게 되는 클래스의 숫자가 대폭 증가하게 된다
- 왜 의존의 증가가 나쁠까?
  - 시스템 어딘가의 무관한 변화가 여러분의 코드에 영향을 미칠 수 있는 위험이 커지기 때문이다
- 예를 들어 Location 클래스가 더 이상 TimeZone을 직접 포함하지 않도록 수정했다면, 여러분 역시 코드를 수정해 주어야 한다
  - 앞의 코드와 같이 직접 위계 구조를 헤집고 다니지 말고, 필요한 정보는 직접 물어보도록 한다

```java
// good
public void plotDate(Date aDate, TimeZone aTimeZone) {
  // ...
}

plotDate(someDate, someSelection.getTimeZone());
```

- Selection에 메서드를 추가하여 직접 시간대를 얻을 수 있도록 하였다
  - 그래프를 그리는 루틴은 시간대가 어디에서 왔는지에 대해서는 상관하지 않는다
- 직접 객체간의 관계를 헤집고 다닌다면 의존 관계가 조합적으로 폭발하게 될 수 있다

  - 이런 현상의 징후는 다양한 방식으로 나타난다
    - 1. 단위 테스트를 링크하기 위한 명령어가 테스트 프로그램 자체보다 긴 대규모 C 혹은 C++ 프로젝트
    - 2. 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역에 퍼져나가는 경우
    - 3. 개발자가 수정한 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우

- 불필요한 의존이 많은 시스템은 유지보수하기 어렵고, 이로 인해 비용이 많이 들며 시스템 자체가 매우 불안정한 경향이 있다
  - 우리는 의존도를 최소화하기 위해 디미터 법칙을 사용하여 메서드, 함수를 설계한다

### 디미터 함수 법칙

- 프로그램에서 모듈간 결합도를 최소화
- 이 법칙은 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다

```C++
class Demeter {
  private:
    A *a;
    Int func();
  public:
    // ...
    void example(B& b);
}
void Demeter::example(B& b) {
  C c;
  Int f = func(); // 자신
  b.invert(); // 메서드로 넘어온 인자
  a = new A();
  a->setActive(); // 자신이 생성한 객체
  c.print(); // 직접 포함하고 있는 객체
}
```

- 디미터 법칙은 객체의 모든 메서드는 다음에 해당하는 메서드만을 호출해야 한다고 말한다

> Tip 36. 모듈간의 결합도를 최소화하라.

### 확실히 차이를 낳는가?

- 디미터 법칙을 따른다면 정말 유지보수하기 좋은 코드를 생성할 수 있을까?
- 연구에 따르면 응답집합이 큰 클래스는 작은 클래스보다 에러를 발생시키기 쉽다고 한다

  - 이때 `응답집합`은 `클래스의 메서드가 직접 호출하는 함수의 수`를 의미한다

- 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다
- 디미터 법칙 -> 위임 -> 성능저하와 메모리 과부화와 같은 문제를 야기할 수 있다 -> 애플리케이션에 맞게 장단점을 잘 고려해야한다
- 대규모 프로젝트에서는 물리적 결합도도 고려해야한다
  - 시스템을 구성하는 파일
  - 디렉터리
  - 라이브러리 간의 관계

### 관련 항목

- 직교성
- 가역성
- 계약에 의한 설계
- 단지 뷰일 뿐이야
- 실용주의 팀
- 가차 없는 테스트

## 27. 메타프로그래밍

- 세부사항은 우리의 깔끔한 코드를 어질러 놓는다
- 세부사항을 코드에서 몰아내라
  - 이렇게 함으로써 우리의 코드는 매우 설정 가능(configurable)하게 되고 '소프트'해진다
  - 즉 변화에 쉽게 적응할 수 있게 되는 것이다

### 동적 설정

- 시스템을 되도록 설정가능하게 만들기 바란다
- 배경 색, 프롬프트 텍스트 뿐 아니라 알고리즘의 선택, 사용할 데이터베이스 제품, 미들웨어 기술, 사용자 인터페이스 스타일 등 시스템의 심층까지
- 이런 아이템들은 통합하거나 엔지니어링하지 말고 설정 옵션으로 구현해야 한다

> Tip 37. 통합하지 말고 설정하라

- 메타데이터를 이용하여 변환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술하라

- 메타데이터란?
  - 데이터에 관한 데이터
  - 데이터베이스 스키마, 데이터 디렉터리 등
- 우리는 메타데이터를 좀 더 넓은 의미로 사용한다

  - 메타데이터는 애플리케이션을 기술하는 모든 데이터다
    - 애클리케이션이 어떻게 실행되어야 하고
    - 어떤 자원을 이용해야 하는지 등을 기술한다면 메타데이터라 할 수 있다

- 보통 메타데이터는 컴파일타임이 아닌 런타임에 접근, 사용된다

### 메타데이터 주도 애플리케이션

- 우리는 메타데이터를 간단한 사용자 설정을 위해 사용하는 것 이상을 원한다
- 가능한 많은 메타데이터를 써서 애플리케이션을 설정하고 실행시켜라
- 어떻게가 아닌 무엇을 해야 하는지를 명시함으로써 선언적으로 생각하고
  이로써 더 동적이고 적응가능한 프로그램을 만드는 것이다
- 이를 위해서 다음의 일반 규칙을 따른다
  - 일반적인 경우에 대해 프로그램을 만들고, 특별한 것들은 컴파일된 코드 밖 어딘가에 내놓는다

> Tip 38. 코드에는 추상화를, 메타데이터에는 세부 내용을

- 이렇게 접근하면 다음의 이점이 생긴다

  - 설계의 결합도를 줄여 좀 더 유연하고 적응성 있는 프로그램을 만들 수 있다
  - 세부사항을 코드 밖으로 몰아냄으로써 보다 강하고 추상적인 디자인을 만들 수 있다
  - 애플리케이션을 커스터마이징하기 위해 다시 컴파일할 필요가 없다
    - 이런 방식의 커스터마이징을 통해 실제 제작 공정 시스템에서 일어날 수 있는 치명적인 버그에서 벗어나는 우회로를 쉽게 만들 수 있다
  - 메타데이터는 범용 프로그래밍 언어보다 문제 도메인에 가까운 방식으로 표현될 수 있다('도메인 언어' 참고)
  - 동일한 애플리케이션 엔짅과 상이한 메타데이터를 이용해 여러 다른 프로젝트를 진행할 수 있게 된다

- 가능한 마지막 순간까지 세부 정의를 피하고, 세부사항을 소프트하게 변화하기 쉽게 남겨 두라

### 비즈니스 로직

- 데이터베이스 엔진을 선택할 수 있는 설정 옵션으로 만들고, 메타데이터를 사용자 인터페이스에서 결정할 수 있도록 하였다
  - 여기서 더 나아갈 수 있을까? 물론이다!
- 비즈니스 정책이나 룰은 프로젝트의 다른 어떤 부분보다 변화하기 쉽기 때문에 이를 유연한 포맷을 통해 유지보수하는 것이 좋다
- 예. 구매 애플리케이션
  - 중소규모 공급자 : 45일 이내 대금 지급, 대규모 공급자 : 90일 이내 대금 지급
  - 공급 유형과 대금 지급 기일을 설정 가능하게 만들어라
  - 일반화할 기회를 놓치지 말자

### 협동적 설정

- 지금까지는 애플리케이션을 동적으로 설정하는 사용자와 개발자에 대해 이야기했다
  - 그러나 애플리케이션들이 서로를 설정하게 만든다면, 소프트웨어가 스스로 환경에 적응하도록 만들면 어떨까?
- 미리 계획되지 않고, 그때그때 맞게 설정되는 시스템이 있다면 매우 강력할 것이다
  - 운영체제는 이미 부팅하면서 자신을 하드웨어에 맞게 설정하고,
  - 웹 브라우저는 자동으로 새로운 컴포넌트를 업데이트한다
- 여러분이 사용하는 대규모 애플리케이션이라면 아마도 이미 다른 버전의 데이터나 상이한 라이브러리, 운영체제 배포와 같은 문제에 직면하고 있을 것이다

  - 이때 좀 더 동적인 접근을 한다면 도움이 된다

- 내 경험
  - package.json에서 환경변수를 스크립트마다 다르게 설정하여 다른 설정으로 실행할 수 있도록 하였다

### 도도 코드를 작성하기 말라

- 메타데이터를 사용하지 않는다면 코드는 최대한 적응성이나 유연성을 얻을 수 없다
- 이것은 정말 나쁜 일인가?
  - 실세계에서도 환경에 적응하지 못하는 종은 멸종하게 된다
  - 모리셔스 섬의 도도는 인간과 가축의 등장에 적응하지 못했고, 빠르게 멸종됐다
- 여러분의 프로젝트가(또한 경력이) 도도의 전철을 밟지 않도록 하라

### 관련 항목

- 직교성
- 가역성
- 도메인 언어
- 일반 텍스트의 힘

### 연습문제

- 다음 목록 가운데 어떤 것이 프로그램 안의 코드로 표현하는 편이 더 나으며,
  어떤 것이 외부 메타데이터로 표현하는 편이 더 나을까?
  - 1. 통신 포트 할당
  - 2. 다양한 언어의 문법을 강조하는 텍스트 편집기 기능
  - 3. 상이한 그래픽 장치들을 지원하는 텍스트 편집기 기능
  - 4. 파서나 스캐너용 상태 기계
  - 5. 단위 테스트에서 쓰기 위한 샘플 값과 결과들
