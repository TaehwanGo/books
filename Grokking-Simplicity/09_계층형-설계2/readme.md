# 9. 계층형 설계 2

- 이전 8장에서 호출 그래프를 그리는 방법과 코드를 잘 구조화하기 위한 계층을 찾아봤습니다
- 이번 9장에서는 계층형 설계를 더 잘 이해해 보고 나머지 세 개 패턴을 보면서 디자인 감각을 갈고닦아 봅시다
- 남은 세 개 패턴으로 유지보수와 테스트, 재사용하기 좋은 코드를 만들 수 있습니다

#### 이번 장에서 살펴볼 내용

- 코드를 모듈화하기 위해 `추상화 벽`을 만드는 법을 배웁니다
- `좋은 인터페이스`가 어떤 것이고, 어떻게 찾는지 알아봅니다
- `설계가 이만하면 되었다고 할 수 있는 시점`을 압니다
- 왜 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지 이해합니다

## 계층형 설계 패턴

- 우리는 아래 네 개의 패턴을 통해 계층형 설계에 대해 알아보고 있다

### 패턴 1: 직접 구현

- 직접 구현은 계층형 설계 구조를 만드는 데 도움이 됩니다
- 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 합니다
- 만약 너무 구체적이라면 코드에서 나는 냄새입니다
- `함수가 모두 비슷한 계층에 있다`면 `직접 구현`했다고 할 수 있습니다

### 패턴 2: 추상화 벽

- 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 `인터페이스를 제공`합니다
- 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있습니다
- 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있습니다

### 패턴 3: 작은 인터페이스

- 시스템이 커질 수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋습니다
- 다른 동작도 직간접적으로 `최소한의 인터페이스를 유지`하면서 정의해야 합니다

### 패턴 4: 편리한 계층

- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 합니다
- 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 합니다
- 그냥 좋아서 계층을 추가하면 안됩니다
- 코드와 그 코드가 속한 `추상화 계층은 작업할 때 편리해야 합니다`

## 패턴 2: 추상화 벽

- 추상화 벽(abstraction barrier)은 여러 가지 문제를 해결합니다
  - 그 중 하나는 팀 간 `책임을 명확하게 나누는 것`입니다

## 추상화 벽으로 구현을 감춥니다

- `추상화 벽`은 `세부 구현을 감춘 함수로 이루어진 계층`입니다
- 예를 들어 마케팅팀은 지저분한 반복문이나 배열을 직접 다루지 않고 마케팅 코드를 만들기 위해 추상화 벽에 있는 함수를 사용할 수 있습니다

- 8장의 remove_item_by_name() 함수는 장바구니 데이터 구조에 대한 추상화 벽입니다
- 내 생각
  - React에서 custom hook을 만드는 것도 추상과 벽을 만드는 것이라고 생각한다
  - 퍼사드 패턴과 비슷하다고 생각한다

## 세부적인 것을 감추는 것은 대칭적입니다

- 추상화 벽을 사용하면 마케팅팀이 세부 구현을 신경 쓰지 않아도 됩니다
  - 신경쓰지 않아도 된다는 것은 대칭적입니다
- `추상화 벽을 만든 개발팀`은 추상화 벽에 있는 함수를 사용하는 `마케팅 관련 코드를 신경쓰지 않아`도 됩니다
  - 두 팀 모두 독립적으로 일할 수 있습니다
- 추상화 벽은 흔하게 사용하는 `라이브러리나 API와 비슷하다`는 것을 느꼈을 것입니다

## 장바구니 데이터 구조 바꾸기

- `추상화 벽 장점`의 `예시`로 장바구니 `데이터 구조를 변경`해보자
- 배열을 순서대로 검색하는 것은 성능이 떨어진다
  - 배열 대신 자바스크립트 객체를 해시 맵처럼 써보자

## 장바구니를 객체로 다시 만들기

- 장바구니를 자바스크립트 객체로 다시 만들어보자
- 지금은 직접 구현 패턴에 더 가깝다

### 배열로 만든 장바구니

```js
// 제품 추가하기
function add_item(cart, item) {
  return add_element_last(cart, item);
}

// 합계 계산하기
function calc_total(cart) {
  let total = 0;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    total += item.price;
  }
  return total;
}

// 제품 이름으로 가격 설정하기
function setPriceByName(cart, name, price) {
  const cartCopy = cart.slice();
  for (let i = 0; i < cartCopy.length; i++) {
    if (cartCopy[i].name === name) {
      cartCopy[i] = setPrice(cartCopy[i], price);
    }
  }
  return cartCopy;
}

function remove_item_by_name(cart, name) {
  let idx = indexOfItem(cart, name);
  if (idx !== null) {
    return splice(cart, idx, 1);
  }
  return cart;
}

function indexOfItem(cart, name) {
  for (let i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      return i;
    }
  }
  return null;
}

function isInCart(cart, name) {
  return indexOfItem(cart, name) !== null;
}
```

### 객체로 만든 장바구니

```js
// 제품 추가하기
function add_item(cart, item) {
  return objectSet(cart, item.name, item);
}

// 합계 계산하기
function calc_total(cart) {
  let total = 0;
  const names = Object.keys(cart);
  for (let i = 0; names.length; i++) {
    const item = cart[names[i]];
    total += item.price;
  }
  return total;
}

// 제품 이름으로 가격 설정하기
function setPriceByName(cart, name, price) {
  if (isInCart(cart, name)) {
    const item = cart[name];
    const copy = setPrice(item, price);
    return objectSet(cart, name, copy);
  } else {
    const item = make_item(name, price);
    return objectSet(cart, name, item);
  }
}

function remove_item_by_name(cart, name) {
  return objectDelete(cart, name);
}

// indexOfItem 는 더 이상 필요 없기 때문에 없어짐

function isInCart(cart, name) {
  return cart.hasOwnProperty(name); // 항목이 있는지 확인하는 자바스크립트 객체 메서드
}
```

## 추상화 벽이 있으면 구체적인 것을 신경쓰지 않아도 됩니다

- 내 생각
  - 추상화벽의 장점은 단위 테스트에서 추상화 벽 레벨만 테스트를 하면 리팩터링 후에도 테스트가 깨지지않은 것과 같다
- 장바구니 제품 자료구조 : 배열 -> 객체
- 마케팅팀은 코드를 고치지 않아도 됩니다
- 이 예제에서 추상화 벽이 의미하는 것은 추상화 벽 위에 있는 함수가 데이터 구조를 몰라도 된다는 것을 말합니다

## 추상화 벽은 언제 사용하면 좋을까요?

- 추상화 벽으로 좋은 설계를 만들 수 있습니다
- 하지만 모든 곳에 추상화 벽을 사용하면 안 됩니다
- 추상화 벽은 언제 사용하면 좋을 까요?

### 1. 쉽게 구현을 바꾸기 위해

- 구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에 구현을 바꾸기 쉽습니다
- 프로토타이핑과 같이 최선의 구현을 확신할 수 없는 작업에 유용합니다
- 다른 예로 서버에서 데이터를 받아서 처리해야 하지만 아직은 준비가 되지 않아 임시 데이터를 줘야하는 경우와 같이
  - 뭔가 바뀔 것을 알고 있지만 아직 준비되지 않은 경우에도 좋습니다
- 하지만 이런 장점은 때로는 독이 되기 때문에 주의해야 합니다
  - 만약을 대비해(just in case) 코드를 만드는 경우가 종종 있습니다
  - 쓸데 없는 코드는 줄이는 것이 좋습니다
  - 오지 않을 수도 있는 미래를 위해 불필요한 코드를 작성하는 것은 좋지 않은 습관입니다
  - 데부분의 데이터 구조는 바뀌지 않습니다
    - 예제에서 개발팀이 끝까지 효율성에 대한 생각을 멈추지 않았기 때문에 데이터 구조를 바꿀 수 있었습니다

### 2. 코드를 읽고 쓰기 쉽게 만들기 위해

- 추상화 벽을 사용하면 세부적인 것을 신경쓰지 않아도 됩니다
- 때론 구체적인 것이 버그를 만듭니다
  - 반복문을 쓸 때 초기화 값을 정확히 입력했는지
  - 반복문 종료 조건에 off-by-one 에러가 있지는 않은지
- 추상화 벽을 사용하면 이런 세부적인 것은 신경 쓰지 않고 쉽게 코드를 만들 수 있습니다
- 적절한 것을 감추면 더 생산적인 코드를 만들 수 있습니다

### 3. 팀 간에 조율해야 할 것을 줄이기 위해

- 예제에서 마케팅팀에 이야기 하지 않고 코드를 고치는 것이 가능했습니다
- 각 팀에 관한 구체적인 내용을 서로 신경쓰지 않아도 일할 수 있습니다
- 게다가 더 빠르게 일할 수 있습니다

### 4. 주어진 문제에 집중하기 위해

- 추상화 벽을 사용하면 해결하려는 문제의 구체적인 부분을 무시할 수 있습니다
- 그렇기 때문에 코드에 실수를 줄이고, 만들면서 지치지 않을 수 있습니다

## 패턴 2 리뷰: 추상화 벽

- 추상화 벽으로 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앨 수 있습니다
- 모든 추상화는 다음과 같이 동작합니다
  - 추상화 단계의 상위에 있는 코드와 하위에 있는 코드는 서로 의존하지 않게 정의합니다
  - 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의합니다
  - 추상화 벽으로 추상화를 강력하고 명시적으로 만들 수 있습니다
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려는 함정에 빠지지 않아야 합니다
  - 추상화 벽을 사용하면 코드를 쉽게 고칠 수 있습니다
  - 하지만 코드를 쉽게 고치려고 추상화 벽을 사용하는 것은 아닙니다
  - 추상화 벽은 팀 간에 커뮤니케이션 비용을 줄이고, 복잡한 코들르 명확하게 하기 위해 전략적으로 사용해야 합니다
- 신경 쓰지 않아도 되는 것을 다루는 것이 추상화 벽의 핵심입니다
  - 어느 부분을 신경 쓰지 않도록 만들면 좋을까요?
  - 사람들이 몰라도 되면 좋은 것은 무엇인가요?
  - 어떤 함수들이 세부 사항을 신경 쓰지 않아도 되는 함수들일까요?

## 앞에서 고친 코드는 직접 구현에 더 가깝습니다

- 데이터 구조를 바꿨더니 함수가 대부분 한줄 짜리 코드가 되었습니다
- 하지만 코드 줄 수는 중요하지 않습니다
- 중요한 것은 코드가 `적절한 구체화 수준`과 `일반화`가 되어 있는지 입니다
- 일반적으로 한 줄짜리 코드는 여러 구체화 수준이 섞일 일이 없기 때문에 좋은 코드라는 표시입니다

## 패턴 3: 작은 인터페이스

- 작은 인터페이스 패턴은 `새로운 코드를 추가할 위치에 관한 것`입니다
- `인터페이스를 최소화`하면 하위 계층에 불필요한 기능이 `쓸데없이 커지는 것을 막을 수 있습니다`

### 예시: 마케팅팀에서 시계를 할인하려고 합니다

- 마케팅팀은 새로운 마케팅을 계획하고 있습니다
- 장바구니에 제품을 많이 담은 사람이 시계를 구입하면 10% 할인해 주려고 합니다

### 시계 할인 마케팅을 구현하기 위한 두 가지 방법

- 시계 할인 마케팅을 구현하기 위한 두 가지 방법
  - 방법 1. 추상화 벽에 구현
  - 방법 2. 추상화 벽 위에 있는 계층에 구현

#### 방법 1. 추상화 벽에 구현 - 같은 레벨

- 추상화 벽 게층에 있으면 해시 맵 구조로 되어 있는 장바구니에 접근할 수 있습니다
- 하지만 같은 계층에 있는 함수를 사용할 수 없습니다

```js
function getsWatchDiscount(cart) {
  let total = 0;
  const names = Object.keys(cart);
  for (let i = 0; i < names.length; i++) {
    const item = cart[names[i]];
    total += item.price;
  }
  return total > 100 && cart.hasOwnProperty("watch");
}
```

#### 방법 2. 추상화 벽 위에 있는 계층에 구현

- 추상화 벽 위에 만들면 해시 데이터 구조를 직접 접근할 수 없습니다
- `추상화 벽에 있는 함수를 사용`해서 장바구니에 접근해야 합니다

```js
function getsWatchDiscount(cart) {
  const total = calcTotal(cart);
  const hasWatch = isInCart("watch");
  return total > 100 && hasWatch;
}
```

### 추상화 벽 위에 있는 계층에 구현하는 것이 더 좋습니다

- 추상화 벽위에 있는 계층에 만드는 것이 더 직접 구현에 가깝습니다
- 추상화 벽에 만들면

  - 시스템 하위 계층 코드가 늘어나기 때문에 좋지 않습니다
  - 마케팅 관련 코드를 바꾸고 싶을 때 개발팀에 이야기해서 바꿔야 합니다
  - 추상화 벽에 새로운 함수가 생긴다면 계약이 늘어나는 것과 같습니다
    - 변경이 생긴다면 계약에 사용하는 용어를 서로 맞춰야 하므로 시간이 많이 듭니다
    - 더 많은 코드를 이해하고 더 많이 신경 써야 합니다
    - 이런 점은 추상화 벽의 장점을 약화시킵니다

- `새로운 기능`을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 `상위 계층에 만드는 것`이 `작은 인터페이스 패턴`이라고 할 수 있습니다
  - !! 중요 !!
- 작은 인터페이스 패턴을 사용하면 하위 계층을 고치지 않고 상위 계층에서 문제를 해결할 수 있습니다
- 작은 인터페이스 패턴은 추상화 벽뿐만 아니라 모든 계층에 적용할 수 있는 패턴입니다

### 잘못된 예: 마케팅팀은 장바구니에 제품을 담을 때 로그를 남기려고 합니다

```js
// bad
function add_item(cart, item) {
  logAddToCart(global_user_id, item); // 장바구니에 제품을 담을 때 로그를 남기는 함수를 추가
  return objectSet(cart, item.name, item);
}
```

- 조금 더 복잡한 예제를 통해 잘못된 결정을 하기 쉽다는 것을 알아보자
- 마케팅팀은 새로운 기능이 필요하게 되었습니다
  - 장바구니에 제품을 담기만 하고 사지 않는 고객이 있습니다
  - 이 고객들은 왜 구입을 하지 않을까요?
  - 마케팅팀은 매출을 늘리기 위해 이 질문에 대한 답을 찾으려 합니다
  - 장바구니에 제품을 담을 때 마다 로그를 남겨달라고 요청
- `logAddToCart(user_id, item)`
  - 이제 로그를 남겨야 하는 곳에서 이 코드를 호출하면 됩니다
  - add_item() 함수에서 호출하는 것을 제안
    - 여기가 좋은 위치일까요?
    - 설계의 관점에서 생각해 봅시다
      - 여기에서 로그를 남기면 장점이 무엇인가요?
      - 단점은 무엇인가요?

### 코드 위치에 대한 설계 결정

- add_item() 함수에서 로그를 남기는 것이 요구사항을 맞출 수 있는 가장 쉬운 방법입니다
- 하지만 add_item() 함수에서 로그를 남기기에는 복잡하고 어려운 문제가 있습니다

  - logAddToCart() 함수는 액션입니다
  - add_item() 함수도 액션이 됩니다
  - add_item() 함수를 호출하는 모든 함수가 액션이 되면서 액션이 전체로 퍼집니다
  - 그렇게 되면 테스트하기가 어려워집니다

- add_item() 함수는 원래 계산이기 때문에 아무 곳에서 편하게 쓸 수 있었습니다

  - update_shipping_icon 같은 곳에서도 사용했었는데 이 경우엔 로그를 남기고 싶지 안습니다

- logAddToCart() 함수는 추상화 벽 위에 있는 계층에서 호출하는 것이 좋습니다

### 장바구니 로그를 남길 더 좋은 위치

- logAddToCart() 함수에 대해 두 가지 사실을 알았습니다

  - logAddToCart() 함수는 액션이라는 사실
  - logAddToCart() 함수는 `추상화 벽 위에 있어야 한다`는 점

- logAddToCart()는 어디에 위치해야 할까요?
- add_item_to_cart() 함수가 로그를 남길 좋은 곳 인것 같습니다
  - add_item_to_cart() 함수는 장바구니에 제품을 담을 때 호출하는 핸들러 함수입니다
    - 이 함수는 이미 액션입니다
    - 이 함수는 사용자가 장바구니에 제품을 담을 때 해야할 모든 일을 담는 함수입니다
      - logAddToCart()도 장바구니에 제품을 담을 때 해야할 일 중 하나입니다

```js
// good
function add_item_to_cart(name, place) {
  const item = make_cart_item(name, price);
  shopping_cart = add_item(shopping_cart, item);
  const total = calc_total(shopping_cart);
  set_cart_total_dom(total);
  update_shipping_icon(shopping_cart);
  update_tax_dom(total);
  logAddToCart(); // 사용자가 장바구니에 제품을 담을 때 호출되는 다른 함수들 처럼 여기에 추가하는 것이 좋습니다
}
```

- 이 방법이 유일한 정답은 아지미나 여기서 함수를 부르는 것이 우리가 하려는 설계에 잘 맞습니다
- 만약 더 좋은 위치를 찾기 위해 코드를 수정한다면 애플리케이션 전체를 다시 설계해야 할 것입니다
- 작은 인터페이스 패턴을 사용하면 깨끗하고 단순하고 믿을 수 있는 인터페이스에 집중할 수 있습니다
  - 그리고 감춰진 코드의 나머지 부분을 대신하는 코드로 사용할 수 있습니다
  - 인터페이스가 많아져서 생기는 불필요한 변경이나 확장을 막아줍니다

## 패턴 3 리뷰: 작은 인터페이스

- 내 생각: React 컴포넌트에서 작은 인터페이스
  - 기존에 컴포넌트를 더 재사용하기 쉽게 만들고 그것 위에 새로운 기능이 추가된 컴포넌트를 해당 추상화벽 위에 만든다
  - 아토믹 패턴 폴더의 하위에 일반적인 기능 단위폴더를 하나 더 만들고 그 안에 기본컴포넌트를 기반으로 새로운 기능이 추가된 컴포넌트를 만든다
  - atoms > buttons > Button.tsx, ButtonWithIcon.tsx
- 추상화 벽에 만든 함수는 인터페이스가 됩니다
- 추상화 벽에 있는 인터페이스로 어떤 값의 집합에 접근하거나 값을 조작할 수 있습니다
- 계층형 설계에서 완전한 추상화 벽과 최소한의 인터페이스 사이에 유여한게 조율해야 하는 점이 있다는 것을 알았습니다

  - 작은 인터페이스 : 추상화 벽 위에 있는 인터페이스(`상위 계층에 만드는 것`)

- `추상화 벽을 작게 만들어야 하는 이유`(추상화 벽이 작다 -> 추상화 벽에 함수가 적다 -> 계층이 많다)

  - 1. 추상화 벽에 코드가 많을 수록 구현이 변경되었을 때 고쳐야 할 것이 많습니다
  - 2. 추상화 벽에 있는 코든느 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있습니다
  - 3. 낮은 수준의 코드는 이해하기 더 어렵습니다
  - 4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아집니다
  - 5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵습니다

- 상위 계층에 어떤 함수를 만들 때

  - 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법입니다

- 함수가 하려는 목적을 파악하고 어떤 계층에 구현하는 것이 적합할지 생각해보세요

  - 일반적으로 그래프에서 상위 계층에 구현하는 것이 좋습니다

- 작은 인터페이스는 사실 모든 계층에서 쓸 수 있습니다

  - 예제에선 추상화 벽에서 사용

- 내 생각 : React 폴더구조에서 작은 인터페이스 적용

  - utils 디렉토리에 추상화레벨별로 파일을 만드는 것도 좋을 것 같다
  - hooks : 액션
  - utils : 계산
    - 각 계층으로 구분해서 작은 인터페이스 구현

- 이상적인 계층은 더도 덜도 아닌 필요한 함수만 가지고 있어야 합니다
  - 함수는 바뀌어도 안 되고 나중에 더 늘어나도 안 됩니다
- 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 합니다
- 이것이 작은 인터페이스가 전체 계층에 사용되는 이상적인 모습입니다
- 모든 계층은 아니지만 수년간 소스 파일이 바뀌지 않고 많이 사용되는 코드를 봤을 대 이상적인 모습을 일부에서 발견할 수 있습니다

  - 호출 그래프 하위 계층에 작고 강력한 동작을 만들었을 때 이런 모습을 볼 수 있습니다
  - 하지만, 이런 이상적인 모습을 목표로 하는 것보다 현실적으로 이 목표에 가려고 하는 노력이 중요합니다

- `함수의 목적에 맞는 계층이 어디인지 찾는 감각을 기르는 것이 가장 중요`합니다

## 패턴 4: 편리한 계층

- 앞에서 알아본 패턴 세 개는 계층을 구성하는 것에 관한 패턴입니다
  - 세 개의 패턴은 가장 이상적인 계층 구성을 만드는 방법에 대해 설명하고 있습니다
- 마지막으로 알아볼 패턴은 편리한 계층(comfortable layer)이라고 하는 패턴입니다
  - 다른 패턴과 다르게 조금 더 `현실적이고 실용적인 측면`을 다루고 있습니다
- 강력한 추상과 `계층을 완벽하게 만드는 것은 어렵습니다`

  - 하지만 이러한 실험과 실패도 과정의 일부입니다(내 생각: 도전을 포기하지마세요)

- 프로그래밍 언어 : 기계어에 대한 추상화 벽을 제공
- 비즈니스 문제를 해결하기 위해 일하고 있는 개발자로서 이처럼 거대한 추상 계층을 만들 시간적 여유는 없습니다

  - 너무 오래 걸리고 비즈니스는 기다려주지 않습니다

- 편리한 계층 패턴은 언제 패턴을 적용하고, 언제 적용을 멈춰야 하는지 실용적인 방법을 알려줍니다
- 지금 편리한가요?
  - `만약 작업하는 코드가 편리하다고 느낀다면 설계는 조금 멈춰도 됩니다`
    - 반복문을 감싸지 않고 그대로 두고 호출 화살표가 조금 길어지거나 계층이 다른 계층과 섞여도 그대로 두세요
  - 하지만 구체적인 것을 너무 많이 알아야 하거나, 코드가 지저분하다고 느껴진다면 다시 패턴을 적용하세요
    - 어떤 코드도 이상적인 모습에 도달할 수 없습니다
    - 언제나 설계와 새로운 기능의 필요성 사이 어느 지점에 머물게 됩니다
- 편리한 계층은 언제 멈춰야 할지 알려줍니다
  - 여러분은 팀의 코드를 가지고 일하면서 개발자로서의 필요성과 비즈니스 요구사항 모두를 만족시켜야 합니다

## 계층형 설계 패턴

- 네 가지 계층형 설계 패턴을 모두 알아봤습니다. 앞에서 배운 패턴을 다시 살펴봅시다

### 패턴 1: 직접 구현

- 직접 구현은 계층형 설계 구조를 만드는 데 도움이 됩니다
- 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 합니다
- 만약 너무 구체적이라면 코드에서 나는 냄새입니다
- `함수가 모두 비슷한 계층에 있다`면 `직접 구현`했다고 할 수 있습니다

### 패턴 2: 추상화 벽

- 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 `인터페이스를 제공`합니다
- 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있습니다
- 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있습니다

### 패턴 3: 작은 인터페이스

- 시스템이 커질 수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋습니다
- 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 합니다
- 작은 인터페이스 : 추상화 벽 위에 있는 인터페이스(`상위 계층에 만드는 것`)

### 패턴 4: 편리한 계층

- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 합니다
- 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 합니다
- 그냥 좋아서 계층을 추가하면 안됩니다
- 코드와 그 코드가 속한 추상화 계층은 `작업할 때 편리해야 합니다`

## 그래프로 알 수 있는 코드에 대한 정보는 무엇이 있을까요?

- 호출 그래프의 구조에 있는 코드의 정보에 대해서 알아봅시다
- 호출 그래프는 함수가 어떤 함수를 호출하는지 있는 그대로 보여줍니다
  - 호출 그래프에서 함수 이름을 없애면 구조에 대한 추상적인 모습을 볼 수 있습니다
- 호출 그래프의 구조는 세 가지 중요한 비기능적 요구사항을 꾸밈없이 보여줍니다

  - `기능적 요구사항(functional requirements)`
    - 소프트웨어가 정확히 해야 하는 일을 말합니다
    - e.g. 세금에 대한 계산 => 올바른 계산 결과
  - 비 기능적 요구사항(nonfunctional requirements, NFRs)
    - 테스트를 어떻게 할 것인지, 재사용을 잘 할 수 있는지, 유지보수하기 어렵지 않은지와 같은 요구사항들 입니다

- `비기능적 요구사항`은 소프트웨어 설계를 하는 중요한 이유입니다

  - 이런 것은 보통 `테스트성(testability)` 또는 `재사용성(reusability)`, `유지보수성(maintainability)`과 같이 ~성(ility)라고 부르기도 합니다

- 호출 그래프로 알 수 있는 세 가지 비기능적 요구사하에 대해 알아봅시다

  - 1. 유지보수성(maintainability) : 요구사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드인가요?
  - 2. 테스트성(testability) : 어떤 것을 테스트하는 것이 가장 중요한가요?
  - 3. 재사용성(reusability) : 어떤 함수가 재사용하기 좋나요?

- 호출 그래프에 함수 이름을 빼고 보면, `코드 위치를 통해` 세 가지 `중요한 비기능적 요구사항에 답할 수 있습니다`

## 그래프의 가장 위에 있는 코드가 고치기 가장 쉽습니다

- 함수 이름을 지워 추상화한 호출 그래프로 고치기 쉬운 코드가 어디에 있는지 알 수 있을까요?
  - 네, 알 수 있습니다. 호출 그래프로 비즈니스 규칙처럼 자주 바뀌는 요구사항 코드를 어디에 두면 좋은지 알 수 있습니다
  - 반대로 자주 바뀌면 안되는 코드는 어디에 두는 것이 좋은지도 알 수 있습니다
  - 코드를 적절한 위치에 두면 유지보수 비용을 많이 줄일 수 있습니다
- 가장 높은 계층에 있는 함수 -> 아무 곳에서도 호출하는 곳이 없기 때문에 바꿀 때 고민하지 않아도 됨
- 가장 낮은 계층에 있는 함수 -> 연결된 상위 동작들이 모두 바뀌어야 함. 고치기 어려움

- 작은 인터페이스 패턴 처럼 더 높은 계층에 함수를 추가하는 일은 모두 변경 가능성을 생각해서 계층화하고 있는 것입니다

## 아래에 있는 코드는 테스트가 중요합니다

- 이번에는 그래프를 통해 어떤 코드를 테스트하는 것이 중요한지 알아봅시다
- 모든 코드를 테스트해야한다고 생각할 수 있습니다
- 하지만 `모든 코드를 테스트하는 것은 현실적이지 않습니다`
- 모든 것을 테스트할 수 없다면 장기적으로 좋은 결과를 얻기 위해 어떤 것을 테스트하는 것이 중요할까요?
  - 많은 곳에서 의존하는 `가장 아래에 있는 코드를 테스트하는 것이 중요합니다`

### 제대로 만들었다면 가장 아래에 있는 코드보다 가장 위에 있는 코드가 더 자주 바뀔 것입니다

- 테스트도 만들려면 시간이 걸리는 일입니다
- 그리고 일을 가능한 효율적으로 해야합니다
- 위쪽에 있는 코드가 자주 바뀐다면 해당 코드의 테스트 코드도 바꿔줘야 합니다
- 패턴을 사용하면 테스트 가능성에 맞춰 코드를 계층화할 수 있습니다
  - 하위 계층으로 코드를 추출하거나 `상위 계층에 함수를 만드는 일`은 `테스트의 가치를 결정`합니다

### 하위 계층 코드를 테스트할수록 얻은 것이 더 오래갑니다

## 아래에 있는 코드가 재사용하기 더 좋습니다

- `계층형 구조`를 만들면 자연스럽게 `재사용성이 좋아`지는 것을 봤습니다
- 낮은 계층은 재사용하기 더 좋습니다
- 계층형 설계 패턴을 적용하면 재사용 가능한 계층으로 코드를 만들 수 있습니다

## 요약: 그래프가 코드에 대해 알려주는 것

- 그래프를 통해 코드의 비기능적인 요구사항에 대해 많은 것을 알 수 있었습니다
- 다시 살펴보면서 정리해봅시다

### 유지보수성

- 규칙: 상위 계층에 있는 함수일 수록 바꾸기 쉽습니다
- 핵심: `자주 바뀌는 코드`는 `가능한 위쪽에` 있어야 합니다

### 테스트 가능성

- 규칙: `하위 계층`에 있는 함수를 테스트하는 것이 `더 가치` 있습니다
- 핵심: 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치있습니다

### 재사용성

- 규칙: 아래쪽에 함수가 적을 수록 더 재사용하기 좋습니다
- 핵심: 낮은 수준의 단계로 함수를 빼내면재사용성이 더 높아집니다

- 방금 정리한 규칙은 16장에서 어니언 아키텍처(onion architecture)에 대해 다룰 때 실용적인 예를 통해 더 자세히 알아보겠습니다

## 결론

- 계층형 설계는 바로 아래 계층에 있는 함수로 현재 계층의 함수를 구현해 코드를 구성하는 기술입니다
- 비즈니스 요구를 해결하기 충분히 편리한 코드인지 아닌지는 직관을 따라야 합니다
- 그리고 어떤 코드를 테스트하는 것이 더 좋고, 변경하거나 재사용하기 쉬운 코드는 어떤 코드인지 계층 구조로 알아봤습니다

## 요점정리

- 추상화 벽 패턴을 사용하면 세부적인 것을 완벽히 감출 수 있기 때문에 더 높은 차원에서 생각할 수 있습니다
- 작은 인터페이스 패턴을 사용하면 완성된 인터페이스에 가깝게 계층을 만들 수 있습니다
  - 중요한 비즈니스 개념을 표현하는 인터페이스는 한번 잘 만들어 놓고 더 바뀌거나 늘어나지 않아야 합니다
- 편리한 계층을 이용하면 다른 패턴을 요구사항에 맞게 사용할 수 있습니다
  - 패턴을 사용하다 보면 너무 과한 추상화를 할 수 있습니다
  - 패턴들은 요구사항에 맞게 적용해야 합니다
- 호출 그래프 구조에서 규칙을 얻을 수 있습니다
  - 이 규칙으로 어떤 코드를 테스트하는 것이 가장 좋은지 알 수 있습니다
    - 유지보수나 재사용하기 좋은 코드는 어디에 있는 코드인지 알 수 있습니다

## 다음 장에서 배울 내용

- Part1에서 배운 것들
  - 액션, 계산, 데이터
  - 리팩터링: 함수 추출
- 다음 장에서 `반복문에 대한` 진정한 `추상`을 배우겠습니다
  - 그리고 코드를 데이터처럼 쓰기 위한 두 번째 여정을 시작해보겠습니다
